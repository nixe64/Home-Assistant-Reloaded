{"version":3,"file":"b270479b.js","mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;AAiFA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACDA;;;;;;;;;;;AC0BA;AClEA;;AAEA;AACA;;;AAkOA;AACA;AAGA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;AAhBA;ACrLA;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AA9GA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACPA;AAoEA;;AApEA;;;ACkBA;AACA;;;AAgCA;;;AAGA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AAEA;;AAEA;AAGA;;AAEA;;AAxDA;;;;;;;;;;AAAA;ACXA;AAGA;AC4FA;AAMA;;AAOA;;;;;;AAWA;;AAOA;;AAEA;;;AAyCA;;AAOA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AAGA;;;AAGA;;;;AAIA;AACA;;;;;;AAMA;AACA;AACA;;AAEA;;;;;AAKA;;;;;;;;AAyFA;;;AAGA;;;;AAIA;;;;;;;AAnRA;;AC6KA;AACA;AACA;AACA;AACA;;;;;AAOA;;;;;AAKA;;;;;AAKA;AACA;;;AAKA;;;;;;;;AAUA;AACA;AAGA;;;AAGA;;AAEA;;AAEA;;;;;AAKA;;;AAGA;;AAIA;;AAGA;;;;;AAQA;AACA;AACA;AACA;;;AAKA;AACA;AAGA;AACA;AACA;;;;AAIA;AACA;AAGA;AACA;AACA;;;;;;;AAOA;;AAEA;;;AAKA;;;AAKA;;;AAKA;;AAEA;AACA;AAGA;AACA;;;AAGA;;AAOA;AACA;;;;AAIA;;;;AAIA;;;AAbA;;;;;;AAwBA;;;;AAMA;AACA;AACA;;;;;;AAQA;AAEA;;AAEA;;;AAKA;;AAIA;;;;AAKA;;AAIA;;AAQA;AACA;;;;AAIA;;;;AAIA;;;AAGA;AACA;AACA;AAGA;;;AArBA;;AA2BA;;;;AAKA;;;AAKA;;AAIA;AACA;AACA;AACA;;;;;AAOA;AAEA;;;;AAKA;;AAEA;AACA;AACA;;;;;AA3YA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA","sources":["webpack://home-assistant-frontend/./node_modules/@polymer/paper-item/paper-icon-item.js","webpack://home-assistant-frontend/./node_modules/@polymer/paper-item/paper-item-body.js","webpack://home-assistant-frontend/./node_modules/@polymer/paper-item/paper-item.js","webpack://home-assistant-frontend/./src/components/device/ha-device-picker.ts","webpack://home-assistant-frontend/./src/components/entity/ha-entities-picker.ts","webpack://home-assistant-frontend/./src/components/ha-card.ts","webpack://home-assistant-frontend/./src/components/ha-icon-picker.ts","webpack://home-assistant-frontend/./src/components/ha-state-icon.ts","webpack://home-assistant-frontend/./src/panels/config/scene/ha-scene-dashboard.ts","webpack://home-assistant-frontend/./src/panels/config/scene/ha-scene-editor.ts"],"sourcesContent":["/**\n@license\nCopyright (c) 2015 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at\nhttp://polymer.github.io/LICENSE.txt The complete set of authors may be found at\nhttp://polymer.github.io/AUTHORS.txt The complete set of contributors may be\nfound at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by Google as\npart of the polymer project is also subject to an additional IP rights grant\nfound at http://polymer.github.io/PATENTS.txt\n*/\nimport '@polymer/polymer/polymer-legacy.js';\nimport '@polymer/iron-flex-layout/iron-flex-layout.js';\nimport '@polymer/paper-styles/typography.js';\nimport './paper-item-shared-styles.js';\n\nimport {Polymer} from '@polymer/polymer/lib/legacy/polymer-fn.js';\nimport {html} from '@polymer/polymer/lib/utils/html-tag.js';\n\nimport {PaperItemBehavior} from './paper-item-behavior.js';\n\n/*\n`<paper-icon-item>` is a convenience element to make an item with icon. It is an\ninteractive list item with a fixed-width icon area, according to Material\nDesign. This is useful if the icons are of varying widths, but you want the item\nbodies to line up. Use this like a `<paper-item>`. The child node with the slot\nname `item-icon` is placed in the icon area.\n\n    <paper-icon-item>\n      <iron-icon icon=\"favorite\" slot=\"item-icon\"></iron-icon>\n      Favorite\n    </paper-icon-item>\n    <paper-icon-item>\n      <div class=\"avatar\" slot=\"item-icon\"></div>\n      Avatar\n    </paper-icon-item>\n\n### Styling\n\nThe following custom properties and mixins are available for styling:\n\nCustom property | Description | Default\n----------------|-------------|----------\n`--paper-item-icon-width` | Width of the icon area | `56px`\n`--paper-item-icon` | Mixin applied to the icon area | `{}`\n`--paper-icon-item` | Mixin applied to the item | `{}`\n`--paper-item-selected-weight` | The font weight of a selected item | `bold`\n`--paper-item-selected` | Mixin applied to selected paper-items | `{}`\n`--paper-item-disabled-color` | The color for disabled paper-items | `--disabled-text-color`\n`--paper-item-disabled` | Mixin applied to disabled paper-items | `{}`\n`--paper-item-focused` | Mixin applied to focused paper-items | `{}`\n`--paper-item-focused-before` | Mixin applied to :before focused paper-items | `{}`\n\n*/\nPolymer({\n  _template: html`\n    <style include=\"paper-item-shared-styles\"></style>\n    <style>\n      :host {\n        @apply --layout-horizontal;\n        @apply --layout-center;\n        @apply --paper-font-subhead;\n\n        @apply --paper-item;\n        @apply --paper-icon-item;\n      }\n\n      .content-icon {\n        @apply --layout-horizontal;\n        @apply --layout-center;\n\n        width: var(--paper-item-icon-width, 56px);\n        @apply --paper-item-icon;\n      }\n    </style>\n\n    <div id=\"contentIcon\" class=\"content-icon\">\n      <slot name=\"item-icon\"></slot>\n    </div>\n    <slot></slot>\n`,\n\n  is: 'paper-icon-item',\n  behaviors: [PaperItemBehavior]\n});\n","/**\n@license\nCopyright (c) 2015 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at\nhttp://polymer.github.io/LICENSE.txt The complete set of authors may be found at\nhttp://polymer.github.io/AUTHORS.txt The complete set of contributors may be\nfound at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by Google as\npart of the polymer project is also subject to an additional IP rights grant\nfound at http://polymer.github.io/PATENTS.txt\n*/\nimport '@polymer/polymer/polymer-legacy.js';\n\nimport '@polymer/iron-flex-layout/iron-flex-layout.js';\nimport '@polymer/paper-styles/default-theme.js';\nimport '@polymer/paper-styles/typography.js';\nimport {Polymer} from '@polymer/polymer/lib/legacy/polymer-fn.js';\nimport {html} from '@polymer/polymer/lib/utils/html-tag.js';\n\n/*\nUse `<paper-item-body>` in a `<paper-item>` or `<paper-icon-item>` to make two-\nor three- line items. It is a flex item that is a vertical flexbox.\n\n    <paper-item>\n      <paper-item-body two-line>\n        <div>Show your status</div>\n        <div secondary>Your status is visible to everyone</div>\n      </paper-item-body>\n    </paper-item>\n\nThe child elements with the `secondary` attribute is given secondary text\nstyling.\n\n### Styling\n\nThe following custom properties and mixins are available for styling:\n\nCustom property | Description | Default\n----------------|-------------|----------\n`--paper-item-body-two-line-min-height` | Minimum height of a two-line item | `72px`\n`--paper-item-body-three-line-min-height` | Minimum height of a three-line item | `88px`\n`--paper-item-body-secondary-color` | Foreground color for the `secondary` area | `--secondary-text-color`\n`--paper-item-body-secondary` | Mixin applied to the `secondary` area | `{}`\n\n*/\nPolymer({\n  _template: html`\n    <style>\n      :host {\n        overflow: hidden; /* needed for text-overflow: ellipsis to work on ff */\n        @apply --layout-vertical;\n        @apply --layout-center-justified;\n        @apply --layout-flex;\n      }\n\n      :host([two-line]) {\n        min-height: var(--paper-item-body-two-line-min-height, 72px);\n      }\n\n      :host([three-line]) {\n        min-height: var(--paper-item-body-three-line-min-height, 88px);\n      }\n\n      :host > ::slotted(*) {\n        overflow: hidden;\n        text-overflow: ellipsis;\n        white-space: nowrap;\n      }\n\n      :host > ::slotted([secondary]) {\n        @apply --paper-font-body1;\n\n        color: var(--paper-item-body-secondary-color, var(--secondary-text-color));\n\n        @apply --paper-item-body-secondary;\n      }\n    </style>\n\n    <slot></slot>\n`,\n\n  is: 'paper-item-body'\n});\n","/**\n@license\nCopyright (c) 2015 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at\nhttp://polymer.github.io/LICENSE.txt The complete set of authors may be found at\nhttp://polymer.github.io/AUTHORS.txt The complete set of contributors may be\nfound at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by Google as\npart of the polymer project is also subject to an additional IP rights grant\nfound at http://polymer.github.io/PATENTS.txt\n*/\nimport '@polymer/polymer/polymer-legacy.js';\nimport '@polymer/iron-flex-layout/iron-flex-layout.js';\nimport './paper-item-shared-styles.js';\n\nimport {Polymer} from '@polymer/polymer/lib/legacy/polymer-fn.js';\nimport {html} from '@polymer/polymer/lib/utils/html-tag.js';\n\nimport {PaperItemBehavior} from './paper-item-behavior.js';\n\n/**\nMaterial design:\n[Lists](https://www.google.com/design/spec/components/lists.html)\n\n`<paper-item>` is an interactive list item. By default, it is a horizontal\nflexbox.\n\n    <paper-item>Item</paper-item>\n\nUse this element with `<paper-item-body>` to make Material Design styled\ntwo-line and three-line items.\n\n    <paper-item>\n      <paper-item-body two-line>\n        <div>Show your status</div>\n        <div secondary>Your status is visible to everyone</div>\n      </paper-item-body>\n      <iron-icon icon=\"warning\"></iron-icon>\n    </paper-item>\n\nTo use `paper-item` as a link, wrap it in an anchor tag. Since `paper-item` will\nalready receive focus, you may want to prevent the anchor tag from receiving\nfocus as well by setting its tabindex to -1.\n\n    <a href=\"https://www.polymer-project.org/\" tabindex=\"-1\">\n      <paper-item raised>Polymer Project</paper-item>\n    </a>\n\nIf you are concerned about performance and want to use `paper-item` in a\n`paper-listbox` with many items, you can just use a native `button` with the\n`paper-item` class applied (provided you have correctly included the shared\nstyles):\n\n    <style is=\"custom-style\" include=\"paper-item-shared-styles\"></style>\n\n    <paper-listbox>\n      <button class=\"paper-item\" role=\"option\">Inbox</button>\n      <button class=\"paper-item\" role=\"option\">Starred</button>\n      <button class=\"paper-item\" role=\"option\">Sent mail</button>\n    </paper-listbox>\n\n### Styling\n\nThe following custom properties and mixins are available for styling:\n\nCustom property | Description | Default\n----------------|-------------|----------\n`--paper-item-min-height` | Minimum height of the item | `48px`\n`--paper-item` | Mixin applied to the item | `{}`\n`--paper-item-selected-weight` | The font weight of a selected item | `bold`\n`--paper-item-selected` | Mixin applied to selected paper-items | `{}`\n`--paper-item-disabled-color` | The color for disabled paper-items | `--disabled-text-color`\n`--paper-item-disabled` | Mixin applied to disabled paper-items | `{}`\n`--paper-item-focused` | Mixin applied to focused paper-items | `{}`\n`--paper-item-focused-before` | Mixin applied to :before focused paper-items | `{}`\n\n### Accessibility\n\nThis element has `role=\"listitem\"` by default. Depending on usage, it may be\nmore appropriate to set `role=\"menuitem\"`, `role=\"menuitemcheckbox\"` or\n`role=\"menuitemradio\"`.\n\n    <paper-item role=\"menuitemcheckbox\">\n      <paper-item-body>\n        Show your status\n      </paper-item-body>\n      <paper-checkbox></paper-checkbox>\n    </paper-item>\n\n@group Paper Elements\n@element paper-item\n@demo demo/index.html\n*/\nPolymer({\n  _template: html`\n    <style include=\"paper-item-shared-styles\">\n      :host {\n        @apply --layout-horizontal;\n        @apply --layout-center;\n        @apply --paper-font-subhead;\n\n        @apply --paper-item;\n      }\n    </style>\n    <slot></slot>\n`,\n\n  is: 'paper-item',\n  behaviors: [PaperItemBehavior]\n});\n","import \"@material/mwc-list/mwc-list-item\";\nimport { UnsubscribeFunc } from \"home-assistant-js-websocket\";\nimport { html, LitElement, PropertyValues, TemplateResult } from \"lit\";\nimport { ComboBoxLitRenderer } from \"@vaadin/combo-box/lit\";\nimport { customElement, property, query, state } from \"lit/decorators\";\nimport memoizeOne from \"memoize-one\";\nimport { fireEvent } from \"../../common/dom/fire_event\";\nimport { computeDomain } from \"../../common/entity/compute_domain\";\nimport { stringCompare } from \"../../common/string/compare\";\nimport {\n  AreaRegistryEntry,\n  subscribeAreaRegistry,\n} from \"../../data/area_registry\";\nimport {\n  computeDeviceName,\n  DeviceEntityLookup,\n  DeviceRegistryEntry,\n  subscribeDeviceRegistry,\n} from \"../../data/device_registry\";\nimport {\n  EntityRegistryEntry,\n  subscribeEntityRegistry,\n} from \"../../data/entity_registry\";\nimport { SubscribeMixin } from \"../../mixins/subscribe-mixin\";\nimport { PolymerChangedEvent } from \"../../polymer-types\";\nimport { HomeAssistant } from \"../../types\";\nimport \"../ha-combo-box\";\nimport type { HaComboBox } from \"../ha-combo-box\";\n\ninterface Device {\n  name: string;\n  area: string;\n  id: string;\n}\n\nexport type HaDevicePickerDeviceFilterFunc = (\n  device: DeviceRegistryEntry\n) => boolean;\n\nconst rowRenderer: ComboBoxLitRenderer<Device> = (item) => html`<mwc-list-item\n  .twoline=${!!item.area}\n>\n  <span>${item.name}</span>\n  <span slot=\"secondary\">${item.area}</span>\n</mwc-list-item>`;\n\n@customElement(\"ha-device-picker\")\nexport class HaDevicePicker extends SubscribeMixin(LitElement) {\n  @property({ attribute: false }) public hass!: HomeAssistant;\n\n  @property() public label?: string;\n\n  @property() public value?: string;\n\n  @property() public helper?: string;\n\n  @property() public devices?: DeviceRegistryEntry[];\n\n  @property() public areas?: AreaRegistryEntry[];\n\n  @property() public entities?: EntityRegistryEntry[];\n\n  /**\n   * Show only devices with entities from specific domains.\n   * @type {Array}\n   * @attr include-domains\n   */\n  @property({ type: Array, attribute: \"include-domains\" })\n  public includeDomains?: string[];\n\n  /**\n   * Show no devices with entities of these domains.\n   * @type {Array}\n   * @attr exclude-domains\n   */\n  @property({ type: Array, attribute: \"exclude-domains\" })\n  public excludeDomains?: string[];\n\n  /**\n   * Show only devices with entities of these device classes.\n   * @type {Array}\n   * @attr include-device-classes\n   */\n  @property({ type: Array, attribute: \"include-device-classes\" })\n  public includeDeviceClasses?: string[];\n\n  @property() public deviceFilter?: HaDevicePickerDeviceFilterFunc;\n\n  @property({ type: Boolean }) public disabled?: boolean;\n\n  @property({ type: Boolean }) public required?: boolean;\n\n  @state() private _opened?: boolean;\n\n  @query(\"ha-combo-box\", true) public comboBox!: HaComboBox;\n\n  private _init = false;\n\n  private _getDevices = memoizeOne(\n    (\n      devices: DeviceRegistryEntry[],\n      areas: AreaRegistryEntry[],\n      entities: EntityRegistryEntry[],\n      includeDomains: this[\"includeDomains\"],\n      excludeDomains: this[\"excludeDomains\"],\n      includeDeviceClasses: this[\"includeDeviceClasses\"],\n      deviceFilter: this[\"deviceFilter\"]\n    ): Device[] => {\n      if (!devices.length) {\n        return [\n          {\n            id: \"no_devices\",\n            area: \"\",\n            name: this.hass.localize(\"ui.components.device-picker.no_devices\"),\n          },\n        ];\n      }\n\n      const deviceEntityLookup: DeviceEntityLookup = {};\n\n      if (includeDomains || excludeDomains || includeDeviceClasses) {\n        for (const entity of entities) {\n          if (!entity.device_id) {\n            continue;\n          }\n          if (!(entity.device_id in deviceEntityLookup)) {\n            deviceEntityLookup[entity.device_id] = [];\n          }\n          deviceEntityLookup[entity.device_id].push(entity);\n        }\n      }\n\n      const areaLookup: { [areaId: string]: AreaRegistryEntry } = {};\n      for (const area of areas) {\n        areaLookup[area.area_id] = area;\n      }\n\n      let inputDevices = devices.filter(\n        (device) => device.id === this.value || !device.disabled_by\n      );\n\n      if (includeDomains) {\n        inputDevices = inputDevices.filter((device) => {\n          const devEntities = deviceEntityLookup[device.id];\n          if (!devEntities || !devEntities.length) {\n            return false;\n          }\n          return deviceEntityLookup[device.id].some((entity) =>\n            includeDomains.includes(computeDomain(entity.entity_id))\n          );\n        });\n      }\n\n      if (excludeDomains) {\n        inputDevices = inputDevices.filter((device) => {\n          const devEntities = deviceEntityLookup[device.id];\n          if (!devEntities || !devEntities.length) {\n            return true;\n          }\n          return entities.every(\n            (entity) =>\n              !excludeDomains.includes(computeDomain(entity.entity_id))\n          );\n        });\n      }\n\n      if (includeDeviceClasses) {\n        inputDevices = inputDevices.filter((device) => {\n          const devEntities = deviceEntityLookup[device.id];\n          if (!devEntities || !devEntities.length) {\n            return false;\n          }\n          return deviceEntityLookup[device.id].some((entity) => {\n            const stateObj = this.hass.states[entity.entity_id];\n            if (!stateObj) {\n              return false;\n            }\n            return (\n              stateObj.attributes.device_class &&\n              includeDeviceClasses.includes(stateObj.attributes.device_class)\n            );\n          });\n        });\n      }\n\n      if (deviceFilter) {\n        inputDevices = inputDevices.filter(\n          (device) =>\n            // We always want to include the device of the current value\n            device.id === this.value || deviceFilter!(device)\n        );\n      }\n\n      const outputDevices = inputDevices.map((device) => ({\n        id: device.id,\n        name: computeDeviceName(\n          device,\n          this.hass,\n          deviceEntityLookup[device.id]\n        ),\n        area:\n          device.area_id && areaLookup[device.area_id]\n            ? areaLookup[device.area_id].name\n            : this.hass.localize(\"ui.components.device-picker.no_area\"),\n      }));\n      if (!outputDevices.length) {\n        return [\n          {\n            id: \"no_devices\",\n            area: \"\",\n            name: this.hass.localize(\"ui.components.device-picker.no_match\"),\n          },\n        ];\n      }\n      if (outputDevices.length === 1) {\n        return outputDevices;\n      }\n      return outputDevices.sort((a, b) =>\n        stringCompare(a.name || \"\", b.name || \"\")\n      );\n    }\n  );\n\n  public open() {\n    this.comboBox?.open();\n  }\n\n  public focus() {\n    this.comboBox?.focus();\n  }\n\n  public hassSubscribe(): UnsubscribeFunc[] {\n    return [\n      subscribeDeviceRegistry(this.hass.connection!, (devices) => {\n        this.devices = devices;\n      }),\n      subscribeAreaRegistry(this.hass.connection!, (areas) => {\n        this.areas = areas;\n      }),\n      subscribeEntityRegistry(this.hass.connection!, (entities) => {\n        this.entities = entities;\n      }),\n    ];\n  }\n\n  protected updated(changedProps: PropertyValues) {\n    if (\n      (!this._init && this.devices && this.areas && this.entities) ||\n      (changedProps.has(\"_opened\") && this._opened)\n    ) {\n      this._init = true;\n      (this.comboBox as any).items = this._getDevices(\n        this.devices!,\n        this.areas!,\n        this.entities!,\n        this.includeDomains,\n        this.excludeDomains,\n        this.includeDeviceClasses,\n        this.deviceFilter\n      );\n    }\n  }\n\n  protected render(): TemplateResult {\n    if (!this.devices || !this.areas || !this.entities) {\n      return html``;\n    }\n    return html`\n      <ha-combo-box\n        .hass=${this.hass}\n        .label=${this.label === undefined && this.hass\n          ? this.hass.localize(\"ui.components.device-picker.device\")\n          : this.label}\n        .value=${this._value}\n        .helper=${this.helper}\n        .renderer=${rowRenderer}\n        .disabled=${this.disabled}\n        .required=${this.required}\n        item-value-path=\"id\"\n        item-label-path=\"name\"\n        @opened-changed=${this._openedChanged}\n        @value-changed=${this._deviceChanged}\n      ></ha-combo-box>\n    `;\n  }\n\n  private get _value() {\n    return this.value || \"\";\n  }\n\n  private _deviceChanged(ev: PolymerChangedEvent<string>) {\n    ev.stopPropagation();\n    let newValue = ev.detail.value;\n\n    if (newValue === \"no_devices\") {\n      newValue = \"\";\n    }\n\n    if (newValue !== this._value) {\n      this._setValue(newValue);\n    }\n  }\n\n  private _openedChanged(ev: PolymerChangedEvent<boolean>) {\n    this._opened = ev.detail.value;\n  }\n\n  private _setValue(value: string) {\n    this.value = value;\n    setTimeout(() => {\n      fireEvent(this, \"value-changed\", { value });\n      fireEvent(this, \"change\");\n    }, 0);\n  }\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"ha-device-picker\": HaDevicePicker;\n  }\n}\n","import type { HassEntity } from \"home-assistant-js-websocket\";\nimport { css, html, LitElement, TemplateResult } from \"lit\";\nimport { customElement, property } from \"lit/decorators\";\nimport { fireEvent } from \"../../common/dom/fire_event\";\nimport { isValidEntityId } from \"../../common/entity/valid_entity_id\";\nimport type { PolymerChangedEvent } from \"../../polymer-types\";\nimport type { HomeAssistant } from \"../../types\";\nimport \"./ha-entity-picker\";\nimport type { HaEntityPickerEntityFilterFunc } from \"./ha-entity-picker\";\n\n@customElement(\"ha-entities-picker\")\nclass HaEntitiesPickerLight extends LitElement {\n  @property({ attribute: false }) public hass?: HomeAssistant;\n\n  @property({ type: Array }) public value?: string[];\n\n  @property({ type: Boolean }) public disabled?: boolean;\n\n  @property({ type: Boolean }) public required?: boolean;\n\n  @property() public helper?: string;\n\n  /**\n   * Show entities from specific domains.\n   * @type {string}\n   * @attr include-domains\n   */\n  @property({ type: Array, attribute: \"include-domains\" })\n  public includeDomains?: string[];\n\n  /**\n   * Show no entities of these domains.\n   * @type {Array}\n   * @attr exclude-domains\n   */\n  @property({ type: Array, attribute: \"exclude-domains\" })\n  public excludeDomains?: string[];\n\n  /**\n   * Show only entities of these device classes.\n   * @type {Array}\n   * @attr include-device-classes\n   */\n  @property({ type: Array, attribute: \"include-device-classes\" })\n  public includeDeviceClasses?: string[];\n\n  /**\n   * Show only entities with these unit of measuments.\n   * @type {Array}\n   * @attr include-unit-of-measurement\n   */\n  @property({ type: Array, attribute: \"include-unit-of-measurement\" })\n  public includeUnitOfMeasurement?: string[];\n\n  /**\n   * List of allowed entities to show. Will ignore all other filters.\n   * @type {Array}\n   * @attr include-entities\n   */\n  @property({ type: Array, attribute: \"include-entities\" })\n  public includeEntities?: string[];\n\n  /**\n   * List of entities to be excluded.\n   * @type {Array}\n   * @attr exclude-entities\n   */\n  @property({ type: Array, attribute: \"exclude-entities\" })\n  public excludeEntities?: string[];\n\n  @property({ attribute: \"picked-entity-label\" })\n  public pickedEntityLabel?: string;\n\n  @property({ attribute: \"pick-entity-label\" }) public pickEntityLabel?: string;\n\n  @property() public entityFilter?: HaEntityPickerEntityFilterFunc;\n\n  protected render(): TemplateResult {\n    if (!this.hass) {\n      return html``;\n    }\n\n    const currentEntities = this._currentEntities;\n    return html`\n      ${currentEntities.map(\n        (entityId) => html`\n          <div>\n            <ha-entity-picker\n              allow-custom-entity\n              .curValue=${entityId}\n              .hass=${this.hass}\n              .includeDomains=${this.includeDomains}\n              .excludeDomains=${this.excludeDomains}\n              .includeEntities=${this.includeEntities}\n              .excludeEntities=${this.excludeEntities}\n              .includeDeviceClasses=${this.includeDeviceClasses}\n              .includeUnitOfMeasurement=${this.includeUnitOfMeasurement}\n              .entityFilter=${this._entityFilter}\n              .value=${entityId}\n              .label=${this.pickedEntityLabel}\n              .disabled=${this.disabled}\n              @value-changed=${this._entityChanged}\n            ></ha-entity-picker>\n          </div>\n        `\n      )}\n      <div>\n        <ha-entity-picker\n          allow-custom-entity\n          .hass=${this.hass}\n          .includeDomains=${this.includeDomains}\n          .excludeDomains=${this.excludeDomains}\n          .includeEntities=${this.includeEntities}\n          .excludeEntities=${this.excludeEntities}\n          .includeDeviceClasses=${this.includeDeviceClasses}\n          .includeUnitOfMeasurement=${this.includeUnitOfMeasurement}\n          .entityFilter=${this._entityFilter}\n          .label=${this.pickEntityLabel}\n          .helper=${this.helper}\n          .disabled=${this.disabled}\n          .required=${this.required && !currentEntities.length}\n          @value-changed=${this._addEntity}\n        ></ha-entity-picker>\n      </div>\n    `;\n  }\n\n  private _entityFilter: HaEntityPickerEntityFilterFunc = (\n    stateObj: HassEntity\n  ) =>\n    (!this.value || !this.value.includes(stateObj.entity_id)) &&\n    (!this.entityFilter || this.entityFilter(stateObj));\n\n  private get _currentEntities() {\n    return this.value || [];\n  }\n\n  private async _updateEntities(entities) {\n    this.value = entities;\n\n    fireEvent(this, \"value-changed\", {\n      value: entities,\n    });\n  }\n\n  private _entityChanged(event: PolymerChangedEvent<string>) {\n    event.stopPropagation();\n    const curValue = (event.currentTarget as any).curValue;\n    const newValue = event.detail.value;\n    if (\n      newValue === curValue ||\n      (newValue !== undefined && !isValidEntityId(newValue))\n    ) {\n      return;\n    }\n    const currentEntities = this._currentEntities;\n    if (!newValue || currentEntities.includes(newValue)) {\n      this._updateEntities(currentEntities.filter((ent) => ent !== curValue));\n      return;\n    }\n    this._updateEntities(\n      currentEntities.map((ent) => (ent === curValue ? newValue : ent))\n    );\n  }\n\n  private async _addEntity(event: PolymerChangedEvent<string>) {\n    event.stopPropagation();\n    const toAdd = event.detail.value;\n    if (!toAdd) {\n      return;\n    }\n    (event.currentTarget as any).value = \"\";\n    if (!toAdd) {\n      return;\n    }\n    const currentEntities = this._currentEntities;\n    if (currentEntities.includes(toAdd)) {\n      return;\n    }\n\n    this._updateEntities([...currentEntities, toAdd]);\n  }\n\n  static override styles = css`\n    div {\n      margin-top: 8px;\n    }\n  `;\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"ha-entities-picker\": HaEntitiesPickerLight;\n  }\n}\n","import { css, CSSResultGroup, html, LitElement, TemplateResult } from \"lit\";\nimport { customElement, property } from \"lit/decorators\";\n\n@customElement(\"ha-card\")\nexport class HaCard extends LitElement {\n  @property() public header?: string;\n\n  @property({ type: Boolean, reflect: true }) public outlined = false;\n\n  static get styles(): CSSResultGroup {\n    return css`\n      :host {\n        background: var(\n          --ha-card-background,\n          var(--card-background-color, white)\n        );\n        border-radius: var(--ha-card-border-radius, 4px);\n        box-shadow: var(\n          --ha-card-box-shadow,\n          0px 2px 1px -1px rgba(0, 0, 0, 0.2),\n          0px 1px 1px 0px rgba(0, 0, 0, 0.14),\n          0px 1px 3px 0px rgba(0, 0, 0, 0.12)\n        );\n        color: var(--primary-text-color);\n        display: block;\n        transition: all 0.3s ease-out;\n        position: relative;\n      }\n\n      :host([outlined]) {\n        box-shadow: none;\n        border-width: var(--ha-card-border-width, 1px);\n        border-style: solid;\n        border-color: var(\n          --ha-card-border-color,\n          var(--divider-color, #e0e0e0)\n        );\n      }\n\n      .card-header,\n      :host ::slotted(.card-header) {\n        color: var(--ha-card-header-color, --primary-text-color);\n        font-family: var(--ha-card-header-font-family, inherit);\n        font-size: var(--ha-card-header-font-size, 24px);\n        letter-spacing: -0.012em;\n        line-height: 48px;\n        padding: 12px 16px 16px;\n        display: block;\n        margin-block-start: 0px;\n        margin-block-end: 0px;\n        font-weight: normal;\n      }\n\n      :host ::slotted(.card-content:not(:first-child)),\n      slot:not(:first-child)::slotted(.card-content) {\n        padding-top: 0px;\n        margin-top: -8px;\n      }\n\n      :host ::slotted(.card-content) {\n        padding: 16px;\n      }\n\n      :host ::slotted(.card-actions) {\n        border-top: 1px solid var(--divider-color, #e8e8e8);\n        padding: 5px 16px;\n      }\n    `;\n  }\n\n  protected render(): TemplateResult {\n    return html`\n      ${this.header\n        ? html`<h1 class=\"card-header\">${this.header}</h1>`\n        : html``}\n      <slot></slot>\n    `;\n  }\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"ha-card\": HaCard;\n  }\n}\n","import { css, html, LitElement, PropertyValues, TemplateResult } from \"lit\";\nimport { ComboBoxLitRenderer } from \"@vaadin/combo-box/lit\";\nimport { customElement, property, query, state } from \"lit/decorators\";\nimport { fireEvent } from \"../common/dom/fire_event\";\nimport { customIcons } from \"../data/custom_icons\";\nimport { PolymerChangedEvent } from \"../polymer-types\";\nimport { HomeAssistant } from \"../types\";\nimport \"./ha-combo-box\";\nimport type { HaComboBox } from \"./ha-combo-box\";\nimport \"./ha-icon\";\n\ntype IconItem = {\n  icon: string;\n  keywords: string[];\n};\nlet iconItems: IconItem[] = [{ icon: \"\", keywords: [] }];\nlet iconLoaded = false;\n\n// eslint-disable-next-line lit/prefer-static-styles\nconst rowRenderer: ComboBoxLitRenderer<IconItem> = (item) => html`<mwc-list-item\n  graphic=\"avatar\"\n>\n  <ha-icon .icon=${item.icon} slot=\"graphic\"></ha-icon>\n  ${item.icon}\n</mwc-list-item>`;\n\n@customElement(\"ha-icon-picker\")\nexport class HaIconPicker extends LitElement {\n  @property() public hass?: HomeAssistant;\n\n  @property() public value?: string;\n\n  @property() public label?: string;\n\n  @property() public helper?: string;\n\n  @property() public placeholder?: string;\n\n  @property() public fallbackPath?: string;\n\n  @property({ attribute: \"error-message\" }) public errorMessage?: string;\n\n  @property({ type: Boolean }) public disabled = false;\n\n  @property({ type: Boolean }) public required = false;\n\n  @property({ type: Boolean }) public invalid = false;\n\n  @state() private _opened = false;\n\n  @query(\"ha-combo-box\", true) private comboBox!: HaComboBox;\n\n  protected render(): TemplateResult {\n    return html`\n      <ha-combo-box\n        .hass=${this.hass}\n        item-value-path=\"icon\"\n        item-label-path=\"icon\"\n        .value=${this._value}\n        allow-custom-value\n        .filteredItems=${iconItems}\n        .label=${this.label}\n        .helper=${this.helper}\n        .disabled=${this.disabled}\n        .required=${this.required}\n        .placeholder=${this.placeholder}\n        .errorMessage=${this.errorMessage}\n        .invalid=${this.invalid}\n        .renderer=${rowRenderer}\n        icon\n        @opened-changed=${this._openedChanged}\n        @value-changed=${this._valueChanged}\n        @filter-changed=${this._filterChanged}\n      >\n        ${this._value || this.placeholder\n          ? html`\n              <ha-icon .icon=${this._value || this.placeholder} slot=\"icon\">\n              </ha-icon>\n            `\n          : this.fallbackPath\n          ? html`<ha-svg-icon\n              .path=${this.fallbackPath}\n              slot=\"icon\"\n            ></ha-svg-icon>`\n          : \"\"}\n      </ha-combo-box>\n    `;\n  }\n\n  private async _openedChanged(ev: PolymerChangedEvent<boolean>) {\n    this._opened = ev.detail.value;\n    if (this._opened && !iconLoaded) {\n      const iconList = await import(\"../../build/mdi/iconList.json\");\n\n      iconItems = iconList.default.map((icon) => ({\n        icon: `mdi:${icon.name}`,\n        keywords: icon.keywords,\n      }));\n      iconLoaded = true;\n\n      this.comboBox.filteredItems = iconItems;\n\n      Object.keys(customIcons).forEach((iconSet) => {\n        this._loadCustomIconItems(iconSet);\n      });\n    }\n  }\n\n  private async _loadCustomIconItems(iconsetPrefix: string) {\n    try {\n      const getIconList = customIcons[iconsetPrefix].getIconList;\n      if (typeof getIconList !== \"function\") {\n        return;\n      }\n      const iconList = await getIconList();\n      const customIconItems = iconList.map((icon) => ({\n        icon: `${iconsetPrefix}:${icon.name}`,\n        keywords: icon.keywords ?? [],\n      }));\n      iconItems.push(...customIconItems);\n      this.comboBox.filteredItems = iconItems;\n    } catch (e) {\n      // eslint-disable-next-line\n      console.warn(`Unable to load icon list for ${iconsetPrefix} iconset`);\n    }\n  }\n\n  protected shouldUpdate(changedProps: PropertyValues) {\n    return !this._opened || changedProps.has(\"_opened\");\n  }\n\n  private _valueChanged(ev: PolymerChangedEvent<string>) {\n    ev.stopPropagation();\n    this._setValue(ev.detail.value);\n  }\n\n  private _setValue(value: string) {\n    this.value = value;\n    fireEvent(\n      this,\n      \"value-changed\",\n      { value: this._value },\n      {\n        bubbles: false,\n        composed: false,\n      }\n    );\n  }\n\n  private _filterChanged(ev: CustomEvent): void {\n    const filterString = ev.detail.value.toLowerCase();\n    const characterCount = filterString.length;\n    if (characterCount >= 2) {\n      const filteredItems: IconItem[] = [];\n      const filteredItemsByKeywords: IconItem[] = [];\n\n      iconItems.forEach((item) => {\n        if (item.icon.includes(filterString)) {\n          filteredItems.push(item);\n          return;\n        }\n        if (item.keywords.some((t) => t.includes(filterString))) {\n          filteredItemsByKeywords.push(item);\n        }\n      });\n\n      filteredItems.push(...filteredItemsByKeywords);\n\n      if (filteredItems.length > 0) {\n        this.comboBox.filteredItems = filteredItems;\n      } else {\n        this.comboBox.filteredItems = [{ icon: filterString, keywords: [] }];\n      }\n    } else {\n      this.comboBox.filteredItems = iconItems;\n    }\n  }\n\n  private get _value() {\n    return this.value || \"\";\n  }\n\n  static get styles() {\n    return css`\n      ha-icon,\n      ha-svg-icon {\n        color: var(--primary-text-color);\n        position: relative;\n        bottom: 2px;\n      }\n      *[slot=\"prefix\"] {\n        margin-right: 8px;\n      }\n    `;\n  }\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"ha-icon-picker\": HaIconPicker;\n  }\n}\n","import { HassEntity } from \"home-assistant-js-websocket\";\nimport { html, LitElement, TemplateResult } from \"lit\";\nimport { customElement, property } from \"lit/decorators\";\nimport { stateIconPath } from \"../common/entity/state_icon_path\";\nimport \"./ha-icon\";\nimport \"./ha-svg-icon\";\n\n@customElement(\"ha-state-icon\")\nexport class HaStateIcon extends LitElement {\n  @property({ attribute: false }) public state?: HassEntity;\n\n  @property() public icon?: string;\n\n  protected render(): TemplateResult {\n    if (this.icon || this.state?.attributes.icon) {\n      return html`<ha-icon\n        .icon=${this.icon || this.state?.attributes.icon}\n      ></ha-icon>`;\n    }\n    return html`<ha-svg-icon .path=${stateIconPath(this.state)}></ha-svg-icon>`;\n  }\n}\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"ha-state-icon\": HaStateIcon;\n  }\n}\n","import {\n  mdiContentDuplicate,\n  mdiDelete,\n  mdiHelpCircle,\n  mdiInformationOutline,\n  mdiPencilOff,\n  mdiPlay,\n  mdiPlus,\n} from \"@mdi/js\";\nimport \"@polymer/paper-tooltip/paper-tooltip\";\nimport { css, CSSResultGroup, html, LitElement, TemplateResult } from \"lit\";\nimport { customElement, property, state } from \"lit/decorators\";\nimport memoizeOne from \"memoize-one\";\nimport { fireEvent, HASSDomEvent } from \"../../../common/dom/fire_event\";\nimport { computeStateName } from \"../../../common/entity/compute_state_name\";\nimport { navigate } from \"../../../common/navigate\";\nimport {\n  DataTableColumnContainer,\n  RowClickedEvent,\n} from \"../../../components/data-table/ha-data-table\";\nimport \"../../../components/ha-button-related-filter-menu\";\nimport \"../../../components/ha-fab\";\nimport \"../../../components/ha-icon-button\";\nimport \"../../../components/ha-state-icon\";\nimport \"../../../components/ha-svg-icon\";\nimport \"../../../components/ha-icon-overflow-menu\";\nimport { forwardHaptic } from \"../../../data/haptics\";\nimport {\n  activateScene,\n  deleteScene,\n  getSceneConfig,\n  SceneEntity,\n  showSceneEditor,\n} from \"../../../data/scene\";\nimport {\n  showAlertDialog,\n  showConfirmationDialog,\n} from \"../../../dialogs/generic/show-dialog-box\";\nimport \"../../../layouts/hass-tabs-subpage-data-table\";\nimport { haStyle } from \"../../../resources/styles\";\nimport { HomeAssistant, Route } from \"../../../types\";\nimport { documentationUrl } from \"../../../util/documentation-url\";\nimport { showToast } from \"../../../util/toast\";\nimport { configSections } from \"../ha-panel-config\";\nimport { formatDateTime } from \"../../../common/datetime/format_date_time\";\nimport { UNAVAILABLE_STATES } from \"../../../data/entity\";\n\n@customElement(\"ha-scene-dashboard\")\nclass HaSceneDashboard extends LitElement {\n  @property({ attribute: false }) public hass!: HomeAssistant;\n\n  @property() public narrow!: boolean;\n\n  @property() public isWide!: boolean;\n\n  @property() public route!: Route;\n\n  @property() public scenes!: SceneEntity[];\n\n  @property() private _activeFilters?: string[];\n\n  @state() private _filteredScenes?: string[] | null;\n\n  @state() private _filterValue?;\n\n  private _scenes = memoizeOne(\n    (scenes: SceneEntity[], filteredScenes?: string[] | null) => {\n      if (filteredScenes === null) {\n        return [];\n      }\n      return (\n        filteredScenes\n          ? scenes.filter((scene) => filteredScenes!.includes(scene.entity_id))\n          : scenes\n      ).map((scene) => ({\n        ...scene,\n        name: computeStateName(scene),\n      }));\n    }\n  );\n\n  private _columns = memoizeOne(\n    (_language, narrow): DataTableColumnContainer => {\n      const columns: DataTableColumnContainer = {\n        icon: {\n          title: \"\",\n          label: this.hass.localize(\n            \"ui.panel.config.scene.picker.headers.state\"\n          ),\n          type: \"icon\",\n          template: (_, scene) =>\n            html` <ha-state-icon .state=${scene}></ha-state-icon> `,\n        },\n        name: {\n          title: this.hass.localize(\n            \"ui.panel.config.scene.picker.headers.name\"\n          ),\n          sortable: true,\n          filterable: true,\n          direction: \"asc\",\n          grows: true,\n        },\n      };\n      if (!narrow) {\n        columns.state = {\n          title: this.hass.localize(\n            \"ui.panel.config.scene.picker.headers.last_activated\"\n          ),\n          sortable: true,\n          width: \"30%\",\n          template: (last_activated) => html`\n            ${last_activated && !UNAVAILABLE_STATES.includes(last_activated)\n              ? formatDateTime(new Date(last_activated), this.hass.locale)\n              : this.hass.localize(\"ui.components.relative_time.never\")}\n          `,\n        };\n      }\n      columns.only_editable = {\n        title: \"\",\n        width: \"56px\",\n        template: (_info, scene: any) =>\n          !scene.attributes.id\n            ? html`\n                <paper-tooltip animation-delay=\"0\" position=\"left\">\n                  ${this.hass.localize(\n                    \"ui.panel.config.scene.picker.only_editable\"\n                  )}\n                </paper-tooltip>\n                <ha-svg-icon\n                  .path=${mdiPencilOff}\n                  style=\"color: var(--secondary-text-color)\"\n                ></ha-svg-icon>\n              `\n            : \"\",\n      };\n      columns.actions = {\n        title: \"\",\n        width: \"72px\",\n        type: \"overflow-menu\",\n        template: (_: string, scene: any) =>\n          html`\n            <ha-icon-overflow-menu\n              .hass=${this.hass}\n              narrow\n              .items=${[\n                {\n                  path: mdiInformationOutline,\n                  label: this.hass.localize(\n                    \"ui.panel.config.scene.picker.show_info\"\n                  ),\n                  action: () => this._showInfo(scene),\n                },\n                {\n                  path: mdiPlay,\n                  label: this.hass.localize(\n                    \"ui.panel.config.scene.picker.activate\"\n                  ),\n                  action: () => this._activateScene(scene),\n                },\n                {\n                  divider: true,\n                },\n                {\n                  path: mdiContentDuplicate,\n                  label: this.hass.localize(\n                    \"ui.panel.config.scene.picker.duplicate\"\n                  ),\n                  action: () => this._duplicate(scene),\n                  disabled: !scene.attributes.id,\n                },\n                {\n                  label: this.hass.localize(\n                    \"ui.panel.config.scene.picker.delete\"\n                  ),\n                  path: mdiDelete,\n                  action: () => this._deleteConfirm(scene),\n                  warning: scene.attributes.id,\n                  disabled: !scene.attributes.id,\n                },\n              ]}\n            >\n            </ha-icon-overflow-menu>\n          `,\n      };\n\n      return columns;\n    }\n  );\n\n  protected render(): TemplateResult {\n    return html`\n      <hass-tabs-subpage-data-table\n        .hass=${this.hass}\n        .narrow=${this.narrow}\n        back-path=\"/config\"\n        .route=${this.route}\n        .tabs=${configSections.automations}\n        .columns=${this._columns(this.hass.locale, this.narrow)}\n        id=\"entity_id\"\n        .data=${this._scenes(this.scenes, this._filteredScenes)}\n        .activeFilters=${this._activeFilters}\n        .noDataText=${this.hass.localize(\n          \"ui.panel.config.scene.picker.no_scenes\"\n        )}\n        @clear-filter=${this._clearFilter}\n        hasFab\n        clickable\n        @row-click=${this._handleRowClicked}\n      >\n        <ha-icon-button\n          slot=\"toolbar-icon\"\n          @click=${this._showHelp}\n          .label=${this.hass.localize(\"ui.common.help\")}\n          .path=${mdiHelpCircle}\n        ></ha-icon-button>\n        <ha-button-related-filter-menu\n          slot=\"filter-menu\"\n          corner=\"BOTTOM_START\"\n          .narrow=${this.narrow}\n          .hass=${this.hass}\n          .value=${this._filterValue}\n          exclude-domains='[\"scene\"]'\n          @related-changed=${this._relatedFilterChanged}\n        >\n        </ha-button-related-filter-menu>\n        <a href=\"/config/scene/edit/new\" slot=\"fab\">\n          <ha-fab\n            .label=${this.hass.localize(\n              \"ui.panel.config.scene.picker.add_scene\"\n            )}\n            extended\n          >\n            <ha-svg-icon slot=\"icon\" .path=${mdiPlus}></ha-svg-icon>\n          </ha-fab>\n        </a>\n      </hass-tabs-subpage-data-table>\n    `;\n  }\n\n  private _handleRowClicked(ev: HASSDomEvent<RowClickedEvent>) {\n    const scene = this.scenes.find((a) => a.entity_id === ev.detail.id);\n\n    if (scene?.attributes.id) {\n      navigate(`/config/scene/edit/${scene?.attributes.id}`);\n    }\n  }\n\n  private _relatedFilterChanged(ev: CustomEvent) {\n    this._filterValue = ev.detail.value;\n    if (!this._filterValue) {\n      this._clearFilter();\n      return;\n    }\n    this._activeFilters = [ev.detail.filter];\n    this._filteredScenes = ev.detail.items.scene || null;\n  }\n\n  private _clearFilter() {\n    this._filteredScenes = undefined;\n    this._activeFilters = undefined;\n    this._filterValue = undefined;\n  }\n\n  private _showInfo(scene: SceneEntity) {\n    fireEvent(this, \"hass-more-info\", { entityId: scene.entity_id });\n  }\n\n  private _activateScene = async (scene: SceneEntity) => {\n    await activateScene(this.hass, scene.entity_id);\n    showToast(this, {\n      message: this.hass.localize(\"ui.panel.config.scene.activated\", {\n        name: computeStateName(scene),\n      }),\n    });\n    forwardHaptic(\"light\");\n  };\n\n  private _deleteConfirm(scene: SceneEntity): void {\n    showConfirmationDialog(this, {\n      title: this.hass!.localize(\n        \"ui.panel.config.scene.picker.delete_confirm_title\"\n      ),\n      text: this.hass!.localize(\n        \"ui.panel.config.scene.picker.delete_confirm_text\",\n        { name: computeStateName(scene) }\n      ),\n      confirmText: this.hass!.localize(\"ui.common.delete\"),\n      dismissText: this.hass!.localize(\"ui.common.cancel\"),\n      confirm: () => this._delete(scene),\n      destructive: true,\n    });\n  }\n\n  private async _delete(scene: SceneEntity): Promise<void> {\n    if (scene.attributes.id) {\n      await deleteScene(this.hass, scene.attributes.id);\n    }\n  }\n\n  private async _duplicate(scene) {\n    if (scene.attributes.id) {\n      const config = await getSceneConfig(this.hass, scene.attributes.id);\n      showSceneEditor({\n        ...config,\n        id: undefined,\n        name: `${config?.name} (${this.hass.localize(\n          \"ui.panel.config.scene.picker.duplicate\"\n        )})`,\n      });\n    }\n  }\n\n  private _showHelp() {\n    showAlertDialog(this, {\n      title: this.hass.localize(\"ui.panel.config.scene.picker.header\"),\n      text: html`\n        ${this.hass.localize(\"ui.panel.config.scene.picker.introduction\")}\n        <p>\n          <a\n            href=${documentationUrl(this.hass, \"/docs/scene/editor/\")}\n            target=\"_blank\"\n            rel=\"noreferrer\"\n          >\n            ${this.hass.localize(\"ui.panel.config.scene.picker.learn_more\")}\n          </a>\n        </p>\n      `,\n    });\n  }\n\n  static get styles(): CSSResultGroup {\n    return [\n      haStyle,\n      css`\n        a {\n          text-decoration: none;\n        }\n      `,\n    ];\n  }\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"ha-scene-dashboard\": HaSceneDashboard;\n  }\n}\n","import { ActionDetail } from \"@material/mwc-list/mwc-list-foundation\";\nimport \"@material/mwc-list/mwc-list-item\";\nimport {\n  mdiContentDuplicate,\n  mdiContentSave,\n  mdiDelete,\n  mdiDotsVertical,\n} from \"@mdi/js\";\nimport \"@polymer/paper-item/paper-icon-item\";\nimport \"@polymer/paper-item/paper-item\";\nimport \"@polymer/paper-item/paper-item-body\";\nimport { HassEvent } from \"home-assistant-js-websocket\";\nimport {\n  css,\n  CSSResultGroup,\n  html,\n  LitElement,\n  PropertyValues,\n  TemplateResult,\n} from \"lit\";\nimport { customElement, property, state } from \"lit/decorators\";\nimport { classMap } from \"lit/directives/class-map\";\nimport memoizeOne from \"memoize-one\";\nimport { fireEvent } from \"../../../common/dom/fire_event\";\nimport { computeDomain } from \"../../../common/entity/compute_domain\";\nimport { computeStateName } from \"../../../common/entity/compute_state_name\";\nimport { navigate } from \"../../../common/navigate\";\nimport { computeRTL } from \"../../../common/util/compute_rtl\";\nimport { afterNextRender } from \"../../../common/util/render-status\";\nimport \"../../../components/device/ha-device-picker\";\nimport \"../../../components/entity/ha-entities-picker\";\nimport \"../../../components/ha-area-picker\";\nimport \"../../../components/ha-button-menu\";\nimport \"../../../components/ha-card\";\nimport \"../../../components/ha-fab\";\nimport \"../../../components/ha-icon-button\";\nimport \"../../../components/ha-icon-picker\";\nimport \"../../../components/ha-svg-icon\";\nimport \"../../../components/ha-textfield\";\nimport {\n  computeDeviceName,\n  DeviceRegistryEntry,\n  subscribeDeviceRegistry,\n} from \"../../../data/device_registry\";\nimport {\n  EntityRegistryEntry,\n  subscribeEntityRegistry,\n  updateEntityRegistryEntry,\n} from \"../../../data/entity_registry\";\nimport {\n  activateScene,\n  applyScene,\n  deleteScene,\n  getSceneConfig,\n  getSceneEditorInitData,\n  saveScene,\n  SceneConfig,\n  SceneEntities,\n  SceneEntity,\n  SceneMetaData,\n  SCENE_IGNORED_DOMAINS,\n  showSceneEditor,\n} from \"../../../data/scene\";\nimport {\n  showAlertDialog,\n  showConfirmationDialog,\n} from \"../../../dialogs/generic/show-dialog-box\";\nimport \"../../../layouts/hass-subpage\";\nimport { KeyboardShortcutMixin } from \"../../../mixins/keyboard-shortcut-mixin\";\nimport { SubscribeMixin } from \"../../../mixins/subscribe-mixin\";\nimport { haStyle } from \"../../../resources/styles\";\nimport { HomeAssistant, Route } from \"../../../types\";\nimport { showToast } from \"../../../util/toast\";\nimport \"../ha-config-section\";\n\ninterface DeviceEntities {\n  id: string;\n  name: string;\n  entities: string[];\n}\n\ninterface DeviceEntitiesLookup {\n  [deviceId: string]: string[];\n}\n\n@customElement(\"ha-scene-editor\")\nexport class HaSceneEditor extends SubscribeMixin(\n  KeyboardShortcutMixin(LitElement)\n) {\n  @property({ attribute: false }) public hass!: HomeAssistant;\n\n  @property() public narrow!: boolean;\n\n  @property() public isWide!: boolean;\n\n  @property() public route!: Route;\n\n  @property() public sceneId: string | null = null;\n\n  @property() public scenes!: SceneEntity[];\n\n  @property() public showAdvanced!: boolean;\n\n  @state() private _dirty = false;\n\n  @state() private _errors?: string;\n\n  @state() private _config?: SceneConfig;\n\n  @state() private _entities: string[] = [];\n\n  private _single_entities: string[] = [];\n\n  @state() private _devices: string[] = [];\n\n  @state()\n  private _deviceRegistryEntries: DeviceRegistryEntry[] = [];\n\n  @state()\n  private _entityRegistryEntries: EntityRegistryEntry[] = [];\n\n  @state() private _scene?: SceneEntity;\n\n  private _storedStates: SceneEntities = {};\n\n  private _unsubscribeEvents?: () => void;\n\n  private _deviceEntityLookup: DeviceEntitiesLookup = {};\n\n  private _activateContextId?: string;\n\n  @state() private _saving = false;\n\n  // undefined means not set in this session\n  // null means picked nothing.\n  @state() private _updatedAreaId?: string | null;\n\n  // Callback to be called when scene is set.\n  private _scenesSet?: () => void;\n\n  private _getRegistryAreaId = memoizeOne(\n    (entries: EntityRegistryEntry[], entity_id: string) => {\n      const entry = entries.find((ent) => ent.entity_id === entity_id);\n      return entry ? entry.area_id : null;\n    }\n  );\n\n  private _getEntitiesDevices = memoizeOne(\n    (\n      entities: string[],\n      devices: string[],\n      deviceEntityLookup: DeviceEntitiesLookup,\n      deviceRegs: DeviceRegistryEntry[]\n    ) => {\n      const outputDevices: DeviceEntities[] = [];\n\n      if (devices.length) {\n        const deviceLookup: { [deviceId: string]: DeviceRegistryEntry } = {};\n        for (const device of deviceRegs) {\n          deviceLookup[device.id] = device;\n        }\n\n        devices.forEach((deviceId) => {\n          const device = deviceLookup[deviceId];\n          const deviceEntities: string[] = deviceEntityLookup[deviceId] || [];\n          outputDevices.push({\n            name: computeDeviceName(\n              device,\n              this.hass,\n              this._deviceEntityLookup[device.id]\n            ),\n            id: device.id,\n            entities: deviceEntities,\n          });\n        });\n      }\n\n      const outputEntities: string[] = [];\n\n      entities.forEach((entity) => {\n        if (!outputDevices.find((device) => device.entities.includes(entity))) {\n          outputEntities.push(entity);\n        }\n      });\n\n      return { devices: outputDevices, entities: outputEntities };\n    }\n  );\n\n  public disconnectedCallback() {\n    super.disconnectedCallback();\n    if (this._unsubscribeEvents) {\n      this._unsubscribeEvents();\n      this._unsubscribeEvents = undefined;\n    }\n  }\n\n  public hassSubscribe() {\n    return [\n      subscribeEntityRegistry(this.hass.connection, (entries) => {\n        this._entityRegistryEntries = entries;\n      }),\n      subscribeDeviceRegistry(this.hass.connection, (entries) => {\n        this._deviceRegistryEntries = entries;\n      }),\n    ];\n  }\n\n  protected render(): TemplateResult {\n    if (!this.hass) {\n      return html``;\n    }\n    const { devices, entities } = this._getEntitiesDevices(\n      this._entities,\n      this._devices,\n      this._deviceEntityLookup,\n      this._deviceRegistryEntries\n    );\n\n    return html`\n      <hass-subpage\n        .hass=${this.hass}\n        .narrow=${this.narrow}\n        .route=${this.route}\n        .backCallback=${this._backTapped}\n        .header=${this._scene\n          ? computeStateName(this._scene)\n          : this.hass.localize(\"ui.panel.config.scene.editor.default_name\")}\n      >\n        <ha-button-menu\n          corner=\"BOTTOM_START\"\n          slot=\"toolbar-icon\"\n          @action=${this._handleMenuAction}\n          activatable\n        >\n          <ha-icon-button\n            slot=\"trigger\"\n            .label=${this.hass.localize(\"ui.common.menu\")}\n            .path=${mdiDotsVertical}\n          ></ha-icon-button>\n\n          <mwc-list-item\n            .disabled=${!this.sceneId}\n            aria-label=${this.hass.localize(\n              \"ui.panel.config.scene.picker.duplicate_scene\"\n            )}\n            graphic=\"icon\"\n          >\n            ${this.hass.localize(\n              \"ui.panel.config.scene.picker.duplicate_scene\"\n            )}\n            <ha-svg-icon\n              slot=\"graphic\"\n              .path=${mdiContentDuplicate}\n            ></ha-svg-icon>\n          </mwc-list-item>\n\n          <mwc-list-item\n            .disabled=${!this.sceneId}\n            aria-label=${this.hass.localize(\n              \"ui.panel.config.scene.picker.delete_scene\"\n            )}\n            class=${classMap({ warning: Boolean(this.sceneId) })}\n            graphic=\"icon\"\n          >\n            ${this.hass.localize(\"ui.panel.config.scene.picker.delete_scene\")}\n            <ha-svg-icon\n              class=${classMap({ warning: Boolean(this.sceneId) })}\n              slot=\"graphic\"\n              .path=${mdiDelete}\n            >\n            </ha-svg-icon>\n          </mwc-list-item>\n        </ha-button-menu>\n        ${this._errors ? html` <div class=\"errors\">${this._errors}</div> ` : \"\"}\n        <div\n          id=\"root\"\n          class=${classMap({\n            rtl: computeRTL(this.hass),\n          })}\n        >\n          ${this._config\n            ? html`\n                <div\n                  class=${classMap({\n                    container: true,\n                    narrow: !this.isWide,\n                  })}\n                >\n                  <ha-card outlined>\n                    <div class=\"card-content\">\n                      <ha-textfield\n                        .value=${this._config.name}\n                        .name=${\"name\"}\n                        @change=${this._valueChanged}\n                        .label=${this.hass.localize(\n                          \"ui.panel.config.scene.editor.name\"\n                        )}\n                      ></ha-textfield>\n                      <ha-icon-picker\n                        .hass=${this.hass}\n                        .label=${this.hass.localize(\n                          \"ui.panel.config.scene.editor.icon\"\n                        )}\n                        .name=${\"icon\"}\n                        .value=${this._config.icon}\n                        @value-changed=${this._valueChanged}\n                      >\n                      </ha-icon-picker>\n                      <ha-area-picker\n                        .hass=${this.hass}\n                        .label=${this.hass.localize(\n                          \"ui.panel.config.scene.editor.area\"\n                        )}\n                        .name=${\"area\"}\n                        .value=${this._sceneAreaIdWithUpdates || \"\"}\n                        @value-changed=${this._areaChanged}\n                      >\n                      </ha-area-picker>\n                    </div>\n                  </ha-card>\n                </div>\n\n                <ha-config-section vertical .isWide=${this.isWide}>\n                  <div slot=\"header\">\n                    ${this.hass.localize(\n                      \"ui.panel.config.scene.editor.devices.header\"\n                    )}\n                  </div>\n                  <div slot=\"introduction\">\n                    ${this.hass.localize(\n                      \"ui.panel.config.scene.editor.devices.introduction\"\n                    )}\n                  </div>\n\n                  ${devices.map(\n                    (device) =>\n                      html`\n                        <ha-card outlined>\n                          <h1 class=\"card-header\">\n                            ${device.name}\n                            <ha-icon-button\n                              .path=${mdiDelete}\n                              .label=${this.hass.localize(\n                                \"ui.panel.config.scene.editor.devices.delete\"\n                              )}\n                              .device=${device.id}\n                              @click=${this._deleteDevice}\n                            ></ha-icon-button>\n                          </h1>\n                          ${device.entities.map((entityId) => {\n                            const entityStateObj = this.hass.states[entityId];\n                            if (!entityStateObj) {\n                              return html``;\n                            }\n                            return html`\n                              <paper-icon-item\n                                .entityId=${entityId}\n                                @click=${this._showMoreInfo}\n                                class=\"device-entity\"\n                              >\n                                <state-badge\n                                  .stateObj=${entityStateObj}\n                                  slot=\"item-icon\"\n                                ></state-badge>\n                                <paper-item-body>\n                                  ${computeStateName(entityStateObj)}\n                                </paper-item-body>\n                              </paper-icon-item>\n                            `;\n                          })}\n                        </ha-card>\n                      `\n                  )}\n\n                  <ha-card\n                    outlined\n                    .header=${this.hass.localize(\n                      \"ui.panel.config.scene.editor.devices.add\"\n                    )}\n                  >\n                    <div class=\"card-content\">\n                      <ha-device-picker\n                        @value-changed=${this._devicePicked}\n                        .hass=${this.hass}\n                        .label=${this.hass.localize(\n                          \"ui.panel.config.scene.editor.devices.add\"\n                        )}\n                      ></ha-device-picker>\n                    </div>\n                  </ha-card>\n                </ha-config-section>\n\n                ${this.showAdvanced\n                  ? html`\n                      <ha-config-section vertical .isWide=${this.isWide}>\n                        <div slot=\"header\">\n                          ${this.hass.localize(\n                            \"ui.panel.config.scene.editor.entities.header\"\n                          )}\n                        </div>\n                        <div slot=\"introduction\">\n                          ${this.hass.localize(\n                            \"ui.panel.config.scene.editor.entities.introduction\"\n                          )}\n                        </div>\n                        ${entities.length\n                          ? html`\n                              <ha-card\n                                outlined\n                                class=\"entities\"\n                                .header=${this.hass.localize(\n                                  \"ui.panel.config.scene.editor.entities.without_device\"\n                                )}\n                              >\n                                ${entities.map((entityId) => {\n                                  const entityStateObj =\n                                    this.hass.states[entityId];\n                                  if (!entityStateObj) {\n                                    return html``;\n                                  }\n                                  return html`\n                                    <paper-icon-item\n                                      .entityId=${entityId}\n                                      @click=${this._showMoreInfo}\n                                      class=\"device-entity\"\n                                    >\n                                      <state-badge\n                                        .stateObj=${entityStateObj}\n                                        slot=\"item-icon\"\n                                      ></state-badge>\n                                      <paper-item-body>\n                                        ${computeStateName(entityStateObj)}\n                                      </paper-item-body>\n                                      <ha-icon-button\n                                        .path=${mdiDelete}\n                                        .entityId=${entityId}\n                                        .label=${this.hass.localize(\n                                          \"ui.panel.config.scene.editor.entities.delete\"\n                                        )}\n                                        @click=${this._deleteEntity}\n                                      ></ha-icon-button>\n                                    </paper-icon-item>\n                                  `;\n                                })}\n                              </ha-card>\n                            `\n                          : \"\"}\n\n                        <ha-card\n                          outlined\n                          header=${this.hass.localize(\n                            \"ui.panel.config.scene.editor.entities.add\"\n                          )}\n                        >\n                          <div class=\"card-content\">\n                            ${this.hass.localize(\n                              \"ui.panel.config.scene.editor.entities.device_entities\"\n                            )}\n                            <ha-entity-picker\n                              @value-changed=${this._entityPicked}\n                              .excludeDomains=${SCENE_IGNORED_DOMAINS}\n                              .hass=${this.hass}\n                              label=${this.hass.localize(\n                                \"ui.panel.config.scene.editor.entities.add\"\n                              )}\n                            ></ha-entity-picker>\n                          </div>\n                        </ha-card>\n                      </ha-config-section>\n                    `\n                  : \"\"}\n              `\n            : \"\"}\n        </div>\n        <ha-fab\n          slot=\"fab\"\n          .label=${this.hass.localize(\"ui.panel.config.scene.editor.save\")}\n          extended\n          .disabled=${this._saving}\n          @click=${this._saveScene}\n          class=${classMap({ dirty: this._dirty, saving: this._saving })}\n        >\n          <ha-svg-icon slot=\"icon\" .path=${mdiContentSave}></ha-svg-icon>\n        </ha-fab>\n      </hass-subpage>\n    `;\n  }\n\n  protected updated(changedProps: PropertyValues): void {\n    super.updated(changedProps);\n\n    const oldscene = changedProps.get(\"sceneId\");\n\n    if (\n      changedProps.has(\"sceneId\") &&\n      this.sceneId &&\n      this.hass &&\n      // Only refresh config if we picked a new scene. If same ID, don't fetch it.\n      (!oldscene || oldscene !== this.sceneId)\n    ) {\n      this._loadConfig();\n    }\n\n    if (changedProps.has(\"sceneId\") && !this.sceneId && this.hass) {\n      this._dirty = false;\n      const initData = getSceneEditorInitData();\n      this._config = {\n        name: this.hass.localize(\"ui.panel.config.scene.editor.default_name\"),\n        entities: {},\n        ...initData?.config,\n      };\n      this._initEntities(this._config);\n      if (initData?.areaId) {\n        this._updatedAreaId = initData.areaId;\n      }\n      this._dirty =\n        initData !== undefined &&\n        (initData.areaId !== undefined || initData.config !== undefined);\n    }\n\n    if (changedProps.has(\"_entityRegistryEntries\")) {\n      this._deviceEntityLookup = {};\n      for (const entity of this._entityRegistryEntries) {\n        if (\n          !entity.device_id ||\n          entity.entity_category ||\n          SCENE_IGNORED_DOMAINS.includes(computeDomain(entity.entity_id))\n        ) {\n          continue;\n        }\n        if (!(entity.device_id in this._deviceEntityLookup)) {\n          this._deviceEntityLookup[entity.device_id] = [];\n        }\n        this._deviceEntityLookup[entity.device_id].push(entity.entity_id);\n        if (\n          this._entities.includes(entity.entity_id) &&\n          !this._single_entities.includes(entity.device_id) &&\n          !this._devices.includes(entity.device_id)\n        ) {\n          this._devices = [...this._devices, entity.device_id];\n        }\n      }\n    }\n    if (\n      changedProps.has(\"scenes\") &&\n      this.sceneId &&\n      this._config &&\n      !this._scene\n    ) {\n      this._setScene();\n    }\n    if (this._scenesSet && changedProps.has(\"scenes\")) {\n      this._scenesSet();\n    }\n  }\n\n  private async _handleMenuAction(ev: CustomEvent<ActionDetail>) {\n    switch (ev.detail.index) {\n      case 0:\n        this._duplicate();\n        break;\n      case 1:\n        this._deleteTapped();\n        break;\n    }\n  }\n\n  private async _setScene() {\n    const scene = this.scenes.find(\n      (entity: SceneEntity) => entity.attributes.id === this.sceneId\n    );\n    if (!scene) {\n      return;\n    }\n    this._scene = scene;\n    const { context } = await activateScene(this.hass, this._scene.entity_id);\n    this._activateContextId = context.id;\n    this._unsubscribeEvents =\n      await this.hass!.connection.subscribeEvents<HassEvent>(\n        (event) => this._stateChanged(event),\n        \"state_changed\"\n      );\n  }\n\n  private _showMoreInfo(ev: Event) {\n    const entityId = (ev.currentTarget as any).entityId;\n    fireEvent(this, \"hass-more-info\", { entityId });\n  }\n\n  private async _loadConfig() {\n    let config: SceneConfig;\n    try {\n      config = await getSceneConfig(this.hass, this.sceneId!);\n    } catch (err: any) {\n      await showAlertDialog(this, {\n        text:\n          err.status_code === 404\n            ? this.hass.localize(\n                \"ui.panel.config.scene.editor.load_error_not_editable\"\n              )\n            : this.hass.localize(\n                \"ui.panel.config.scene.editor.load_error_unknown\",\n                \"err_no\",\n                err.status_code\n              ),\n      });\n      history.back();\n      return;\n    }\n\n    if (!config.entities) {\n      config.entities = {};\n    }\n\n    this._initEntities(config);\n\n    this._setScene();\n\n    this._dirty = false;\n    this._config = config;\n  }\n\n  private _initEntities(config: SceneConfig) {\n    this._entities = Object.keys(config.entities);\n    this._entities.forEach((entity) => this._storeState(entity));\n    this._single_entities = [];\n\n    const filteredEntityReg = this._entityRegistryEntries.filter((entityReg) =>\n      this._entities.includes(entityReg.entity_id)\n    );\n    const newDevices: string[] = [];\n\n    if (config.metadata) {\n      Object.keys(config.entities).forEach((entity) => {\n        if (\n          !this._single_entities.includes(entity) &&\n          config.metadata![entity]?.entity_only\n        ) {\n          this._single_entities.push(entity);\n        }\n      });\n    }\n\n    for (const entityReg of filteredEntityReg) {\n      if (!entityReg.device_id) {\n        continue;\n      }\n      const entityMetaData = config.metadata?.[entityReg.entity_id];\n      if (\n        !newDevices.includes(entityReg.device_id) &&\n        !entityMetaData?.entity_only\n      ) {\n        newDevices.push(entityReg.device_id);\n      }\n    }\n\n    this._devices = newDevices;\n  }\n\n  private _entityPicked(ev: CustomEvent) {\n    const entityId = ev.detail.value;\n    (ev.target as any).value = \"\";\n    if (this._entities.includes(entityId)) {\n      return;\n    }\n    this._entities = [...this._entities, entityId];\n    this._single_entities.push(entityId);\n    this._storeState(entityId);\n    this._dirty = true;\n  }\n\n  private _deleteEntity(ev: Event) {\n    ev.stopPropagation();\n    const deleteEntityId = (ev.target as any).entityId;\n    this._entities = this._entities.filter(\n      (entityId) => entityId !== deleteEntityId\n    );\n    this._single_entities = this._single_entities.filter(\n      (entityId) => entityId !== deleteEntityId\n    );\n    this._dirty = true;\n  }\n\n  private _pickDevice(device_id: string) {\n    if (this._devices.includes(device_id)) {\n      return;\n    }\n    this._devices = [...this._devices, device_id];\n    const deviceEntities = this._deviceEntityLookup[device_id];\n    if (!deviceEntities) {\n      return;\n    }\n    this._entities = [...this._entities, ...deviceEntities];\n    deviceEntities.forEach((entityId) => {\n      this._storeState(entityId);\n    });\n    this._dirty = true;\n  }\n\n  private _devicePicked(ev: CustomEvent) {\n    const device = ev.detail.value;\n    (ev.target as any).value = \"\";\n    this._pickDevice(device);\n  }\n\n  private _deleteDevice(ev: Event) {\n    const deviceId = (ev.target as any).device;\n    this._devices = this._devices.filter((device) => device !== deviceId);\n    const deviceEntities = this._deviceEntityLookup[deviceId];\n    if (!deviceEntities) {\n      return;\n    }\n    this._entities = this._entities.filter(\n      (entityId) => !deviceEntities.includes(entityId)\n    );\n    this._dirty = true;\n  }\n\n  private _valueChanged(ev: Event) {\n    ev.stopPropagation();\n    const target = ev.target as any;\n    const name = target.name;\n    if (!name) {\n      return;\n    }\n    let newVal = (ev as CustomEvent).detail?.value ?? target.value;\n    if (target.type === \"number\") {\n      newVal = Number(newVal);\n    }\n    if ((this._config![name] || \"\") === newVal) {\n      return;\n    }\n    if (!newVal) {\n      delete this._config![name];\n      this._config = { ...this._config! };\n    } else {\n      this._config = { ...this._config!, [name]: newVal };\n    }\n    this._dirty = true;\n  }\n\n  private _areaChanged(ev: CustomEvent) {\n    const newValue = ev.detail.value === \"\" ? null : ev.detail.value;\n\n    if (newValue === (this._sceneAreaIdWithUpdates || \"\")) {\n      return;\n    }\n\n    if (newValue === this._sceneAreaIdCurrent) {\n      this._updatedAreaId = undefined;\n    } else {\n      this._updatedAreaId = newValue;\n      this._dirty = true;\n    }\n  }\n\n  private _stateChanged(event: HassEvent) {\n    if (\n      event.context.id !== this._activateContextId &&\n      this._entities.includes(event.data.entity_id)\n    ) {\n      this._dirty = true;\n    }\n  }\n\n  private _backTapped = async (): Promise<void> => {\n    const result = await this.confirmUnsavedChanged();\n    if (result) {\n      this._goBack();\n    }\n  };\n\n  private _goBack(): void {\n    applyScene(this.hass, this._storedStates);\n    afterNextRender(() => history.back());\n  }\n\n  private _deleteTapped(): void {\n    showConfirmationDialog(this, {\n      title: this.hass!.localize(\n        \"ui.panel.config.scene.picker.delete_confirm_title\"\n      ),\n      text: this.hass!.localize(\n        \"ui.panel.config.scene.picker.delete_confirm_text\",\n        { name: this._config?.name }\n      ),\n      confirmText: this.hass!.localize(\"ui.common.delete\"),\n      dismissText: this.hass!.localize(\"ui.common.cancel\"),\n      confirm: () => this._delete(),\n      destructive: true,\n    });\n  }\n\n  private async _delete(): Promise<void> {\n    await deleteScene(this.hass, this.sceneId!);\n    applyScene(this.hass, this._storedStates);\n    history.back();\n  }\n\n  private async confirmUnsavedChanged(): Promise<boolean> {\n    if (this._dirty) {\n      return showConfirmationDialog(this, {\n        title: this.hass!.localize(\n          \"ui.panel.config.scene.editor.unsaved_confirm_title\"\n        ),\n        text: this.hass!.localize(\n          \"ui.panel.config.scene.editor.unsaved_confirm_text\"\n        ),\n        confirmText: this.hass!.localize(\"ui.common.leave\"),\n        dismissText: this.hass!.localize(\"ui.common.stay\"),\n        destructive: true,\n      });\n    }\n    return true;\n  }\n\n  private async _duplicate() {\n    const result = await this.confirmUnsavedChanged();\n    if (result) {\n      showSceneEditor(\n        {\n          ...this._config,\n          id: undefined,\n          name: `${this._config?.name} (${this.hass.localize(\n            \"ui.panel.config.scene.picker.duplicate\"\n          )})`,\n        },\n        this._sceneAreaIdCurrent || undefined\n      );\n    }\n  }\n\n  private _calculateMetaData(): SceneMetaData {\n    const output: SceneMetaData = {};\n\n    for (const entityId of this._single_entities) {\n      const entityState = this._getCurrentState(entityId);\n\n      if (!entityState) {\n        continue;\n      }\n\n      output[entityId] = {\n        entity_only: true,\n      };\n    }\n\n    return output;\n  }\n\n  private _calculateStates(): SceneEntities {\n    const output: SceneEntities = {};\n    this._entities.forEach((entityId) => {\n      const entityState = this._getCurrentState(entityId);\n      if (entityState) {\n        output[entityId] = entityState;\n      }\n    });\n    return output;\n  }\n\n  private _storeState(entityId: string): void {\n    if (entityId in this._storedStates) {\n      return;\n    }\n    const entityState = this._getCurrentState(entityId);\n    if (!entityState) {\n      return;\n    }\n    this._storedStates[entityId] = entityState;\n  }\n\n  private _getCurrentState(entityId: string) {\n    const stateObj = this.hass.states[entityId];\n    if (!stateObj) {\n      return undefined;\n    }\n    return { ...stateObj.attributes, state: stateObj.state };\n  }\n\n  private async _saveScene(): Promise<void> {\n    const id = !this.sceneId ? \"\" + Date.now() : this.sceneId!;\n    this._config = {\n      ...this._config!,\n      entities: this._calculateStates(),\n      metadata: this._calculateMetaData(),\n    };\n    try {\n      this._saving = true;\n      await saveScene(this.hass, id, this._config);\n\n      if (this._updatedAreaId !== undefined) {\n        let scene =\n          this._scene ||\n          this.scenes.find(\n            (entity: SceneEntity) => entity.attributes.id === id\n          );\n\n        if (!scene) {\n          try {\n            await new Promise<void>((resolve, reject) => {\n              setTimeout(reject, 3000);\n              this._scenesSet = resolve;\n            });\n            scene = this.scenes.find(\n              (entity: SceneEntity) => entity.attributes.id === id\n            );\n          } catch (err) {\n            // We do nothing.\n          } finally {\n            this._scenesSet = undefined;\n          }\n        }\n\n        if (scene) {\n          await updateEntityRegistryEntry(this.hass, scene.entity_id, {\n            area_id: this._updatedAreaId,\n          });\n        }\n\n        this._updatedAreaId = undefined;\n      }\n\n      this._dirty = false;\n\n      if (!this.sceneId) {\n        navigate(`/config/scene/edit/${id}`, { replace: true });\n      }\n    } catch (err: any) {\n      this._errors = err.body.message || err.message;\n      showToast(this, {\n        message: err.body.message || err.message,\n      });\n      throw err;\n    } finally {\n      this._saving = false;\n    }\n  }\n\n  protected handleKeyboardSave() {\n    this._saveScene();\n  }\n\n  private get _sceneAreaIdWithUpdates(): string | undefined | null {\n    return this._updatedAreaId !== undefined\n      ? this._updatedAreaId\n      : this._sceneAreaIdCurrent;\n  }\n\n  private get _sceneAreaIdCurrent(): string | undefined | null {\n    return this._scene\n      ? this._getRegistryAreaId(\n          this._entityRegistryEntries,\n          this._scene.entity_id\n        )\n      : undefined;\n  }\n\n  static get styles(): CSSResultGroup {\n    return [\n      haStyle,\n      css`\n        ha-card {\n          overflow: hidden;\n        }\n        .container {\n          padding: 28px 20px 0;\n          max-width: 1040px;\n          margin: 0 auto;\n        }\n        .narrow.container {\n          max-width: 640px;\n        }\n        .errors {\n          padding: 20px;\n          font-weight: bold;\n          color: var(--error-color);\n        }\n        ha-config-section:last-child {\n          padding-bottom: 20px;\n        }\n        .triggers,\n        .script {\n          margin-top: -16px;\n        }\n        .triggers ha-card,\n        .script ha-card {\n          margin-top: 16px;\n        }\n        .add-card mwc-button {\n          display: block;\n          text-align: center;\n        }\n        .card-menu {\n          position: absolute;\n          top: 0;\n          right: 0;\n          z-index: 1;\n          color: var(--primary-text-color);\n        }\n        .rtl .card-menu {\n          right: auto;\n          left: 0;\n        }\n        .card-menu paper-item {\n          cursor: pointer;\n        }\n        paper-icon-item {\n          padding: 8px 16px;\n        }\n        ha-card ha-icon-button {\n          color: var(--secondary-text-color);\n        }\n        .card-header > ha-icon-button {\n          float: right;\n          position: relative;\n          top: -8px;\n        }\n        .device-entity {\n          cursor: pointer;\n        }\n        span[slot=\"introduction\"] a {\n          color: var(--primary-color);\n        }\n        ha-fab {\n          position: relative;\n          bottom: calc(-80px - env(safe-area-inset-bottom));\n          transition: bottom 0.3s;\n        }\n        ha-fab.dirty {\n          bottom: 0;\n        }\n        ha-fab.saving {\n          opacity: var(--light-disabled-opacity);\n        }\n        ha-icon-picker,\n        ha-area-picker,\n        ha-entity-picker {\n          display: block;\n          margin-top: 8px;\n        }\n        ha-textfield {\n          display: block;\n        }\n      `,\n    ];\n  }\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"ha-scene-editor\": HaSceneEditor;\n  }\n}\n"],"names":[],"sourceRoot":""}