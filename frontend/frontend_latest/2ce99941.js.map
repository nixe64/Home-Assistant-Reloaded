{"version":3,"file":"2ce99941.js","mappings":";;AAyBA;AAGA;;AAEA;;;;AAIA;;AAIA;AAMA;AACA;;;;AAXA;;AA3BA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAyGA;;AC/FA;;;;AARA;;ACQA;;;;AARA;;;ACcA;AACA;AACA;;AAEA;AACA;;AAnBA;;;;AAAA;;ACgCA;;;;AAIA;;AAOA;AACA;AACA;;AAEA;;;;AAKA;AAxCA;AAoGA;AACA;AAGA;;AAEA;AAIA;AAEA;AAIA;AAQA;AAUA;;;AAGA;;AAUA;AAEA;AACA;;;AAtJA;;;AA+MA;AACA;AACA;;AAEA;AACA;;AApNA;;;;;;;;;;;;;;;;AAAA;;ACCA;AACA;AACA;AACA;;;;AAIA;AAnBA;;;;;AAAA;ACDA;;;;;;;;;AALA;;AC8DA;;;AAIA;;AAEA;;AAKA;;AAIA;AACA;;;;;;AAQA;AACA;;AAIA;;AAIA;AACA;;;;AAKA;;;AAGA;;;AAIA;;AAEA;;AAIA;;AAIA;AACA;AACA;;;;;AA1GA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;;ACuBA;AAIA;AACA;;AAIA;;;;AAMA;;;;;;;AAOA;;AAEA;;;;AAKA;;;;;AAKA;;;AAGA;;AAEA;AAEA;AACA;;;;AAnEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;ACFA;;;AAGA;;;;;;;AARA;;;;;;;;;;;;;;;;;;;;;;;AAAA;;;ACoFA;AACA;AACA;;AAEA;AACA;;AA9BA;;AAqGA;AACA;AACA;AACA;AACA;;;AAGA;;AAEA;AACA;AACA;;;;;AAKA;AAUA;;AAEA;AAGA;AACA;AACA;AACA;;AAEA;;AAYA;AAEA;AACA;AACA;;;AAzJA;;AA8LA;AACA;AACA;AACA;AACA;;;AAGA;;AAEA;AACA;AACA;;;;AAIA;;;AAIA;AACA;AACA;;;AAGA;AAQA;AAEA;;;AAGA;AACA;AACA;;;AAGA;;;AAxOA;;AAgRA;AACA;AACA;AACA;AACA;;;;AAIA;;AAEA;AACA;AACA;;;;;AAKA;;;;AAIA;;;;AAIA;AACA;AACA;;;AA3SA;;AAyTA;;AAEA;AACA;AACA;AACA;AACA;;AA/TA;;AA4UA;;AAEA;AACA;AACA;AACA;AACA;;AAlVA;;AA+VA;;AAEA;AACA;AACA;AACA;AACA;;AArWA;;AAoXA;AACA;AACA;AACA;AACA;;;AAGA;;AAEA;AACA;AACA;;;;;;AAMA;AACA;AACA;;AAEA;;AAEA;AACA;;;AA5YA;;AAiaA;;AAEA;AACA;AACA;AACA;AACA;;AAvaA;;AAobA;;AAEA;AACA;AACA;AACA;AACA;;AA1bA;;AAucA;;AAEA;AACA;AACA;AACA;AACA;;AA7cA;;AA2dA;AACA;AACA;AACA;AACA;;;AAGA;;AAEA;AACA;AACA;;;;AAIA;AAGA;AASA;;AAtfA;;AA0gBA;;AAEA;AACA;AACA;AACA;;AA/gBA;;AA4hBA;;AAEA;AACA;AACA;AACA;;AAjiBA;;AAijBA;AAEA;AACA;AAEA;AAKA;AAKA;;;;AAQA;AACA;;;;AAIA;AAEA;;;;AAKA;;;;;AAplBA;;;;;;;;;;;;;;;;AAorBA;AACA;ACvvBA;;;;;;;;;;;;;;;;;;;ADkEA;;AEKA;;AAGA;;AA+FA;;AAKA;AAQA;AAkXA;AACA;;AAOA;AAwHA;;;AASA;AACA;;AAEA;;AAIA;;;;;;;;;;;;;;;;;;AAlIA","sources":["webpack://home-assistant-frontend/./src/components/trace/ha-timeline.ts","webpack://home-assistant-frontend/./src/components/trace/ha-trace-blueprint-config.ts","webpack://home-assistant-frontend/./src/components/trace/ha-trace-config.ts","webpack://home-assistant-frontend/./src/components/trace/ha-trace-logbook.ts","webpack://home-assistant-frontend/./src/components/trace/ha-trace-path-details.ts","webpack://home-assistant-frontend/./src/components/trace/ha-trace-timeline.ts","webpack://home-assistant-frontend/./src/components/trace/hat-logbook-note.ts","webpack://home-assistant-frontend/./src/components/trace/hat-graph-branch.ts","webpack://home-assistant-frontend/./src/components/trace/hat-graph-node.ts","webpack://home-assistant-frontend/./src/components/trace/hat-graph-spacer.ts","webpack://home-assistant-frontend/./src/components/trace/hat-script-graph.ts","webpack://home-assistant-frontend/./src/components/trace/hat-graph-const.ts","webpack://home-assistant-frontend/./src/components/trace/hat-trace-timeline.ts"],"sourcesContent":["import { mdiCircleOutline } from \"@mdi/js\";\nimport { css, html, LitElement, TemplateResult } from \"lit\";\nimport { customElement, property, state } from \"lit/decorators\";\nimport { buttonLinkStyle } from \"../../resources/styles\";\nimport \"../ha-svg-icon\";\n\n@customElement(\"ha-timeline\")\nexport class HaTimeline extends LitElement {\n  @property({ type: Boolean, reflect: true }) public label = false;\n\n  @property({ type: Boolean, reflect: true }) public raised = false;\n\n  @property({ reflect: true, type: Boolean }) notEnabled = false;\n\n  @property({ type: Boolean }) public lastItem = false;\n\n  @property({ type: String }) public icon?: string;\n\n  @property({ attribute: false }) public moreItems?: TemplateResult[];\n\n  @state() private _showMore = false;\n\n  protected render() {\n    return html`\n      <div class=\"timeline-start\">\n        ${this.label\n          ? \"\"\n          : html`\n              <ha-svg-icon .path=${this.icon || mdiCircleOutline}></ha-svg-icon>\n            `}\n        ${this.lastItem ? \"\" : html`<div class=\"line\"></div>`}\n      </div>\n      <div class=\"content\">\n        <slot></slot>\n        ${!this.moreItems\n          ? \"\"\n          : html`\n              <div>\n                ${this._showMore ||\n                // If there is only 1 item hidden behind \"show more\", just show it\n                // instead of showing the more info link. We're not animals.\n                this.moreItems.length === 1\n                  ? this.moreItems\n                  : html`\n                      <button class=\"link\" @click=${this._handleShowMore}>\n                        Show ${this.moreItems.length} more items\n                      </button>\n                    `}\n              </div>\n            `}\n      </div>\n    `;\n  }\n\n  private _handleShowMore() {\n    this._showMore = true;\n  }\n\n  static get styles() {\n    return [\n      css`\n        :host {\n          display: flex;\n          flex-direction: row;\n        }\n        :host(:not([lastItem])) {\n          min-height: 50px;\n        }\n        :host([label]) {\n          margin-top: -8px;\n          font-style: italic;\n          color: var(--timeline-label-color, var(--secondary-text-color));\n        }\n        .timeline-start {\n          display: flex;\n          flex-direction: column;\n          align-items: center;\n          margin-right: 8px;\n          width: 24px;\n        }\n        :host([notEnabled]) ha-svg-icon {\n          opacity: 0.5;\n        }\n        ha-svg-icon {\n          color: var(\n            --timeline-ball-color,\n            var(--timeline-color, var(--secondary-text-color))\n          );\n          border-radius: 50%;\n        }\n        :host([raised]) ha-svg-icon {\n          transform: scale(1.3);\n        }\n        .line {\n          flex: 1;\n          width: 2px;\n          background-color: var(\n            --timeline-line-color,\n            var(--timeline-color, var(--secondary-text-color))\n          );\n          margin: 4px 0;\n        }\n        .content {\n          margin-top: 2px;\n        }\n        :host(:not([lastItem])) .content {\n          padding-bottom: 16px;\n        }\n        :host([label]) .content {\n          margin-top: 0;\n          padding-top: 6px;\n        }\n      `,\n      buttonLinkStyle,\n    ];\n  }\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"ha-timeline\": HaTimeline;\n  }\n}\n","import { dump } from \"js-yaml\";\nimport { html, LitElement, TemplateResult } from \"lit\";\nimport { customElement, property } from \"lit/decorators\";\nimport \"../ha-code-editor\";\nimport \"../ha-icon-button\";\nimport { TraceExtended } from \"../../data/trace\";\nimport { HomeAssistant } from \"../../types\";\n\n@customElement(\"ha-trace-blueprint-config\")\nexport class HaTraceBlueprintConfig extends LitElement {\n  @property({ attribute: false }) public hass!: HomeAssistant;\n\n  @property({ attribute: false }) public trace!: TraceExtended;\n\n  protected render(): TemplateResult {\n    return html`\n      <ha-code-editor\n        .value=${dump(this.trace.blueprint_inputs || \"\").trimRight()}\n        readOnly\n        dir=\"ltr\"\n      ></ha-code-editor>\n    `;\n  }\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"ha-trace-blueprint-config\": HaTraceBlueprintConfig;\n  }\n}\n","import { dump } from \"js-yaml\";\nimport { css, CSSResultGroup, html, LitElement, TemplateResult } from \"lit\";\nimport { customElement, property } from \"lit/decorators\";\nimport \"../ha-code-editor\";\nimport \"../ha-icon-button\";\nimport { TraceExtended } from \"../../data/trace\";\nimport { HomeAssistant } from \"../../types\";\n\n@customElement(\"ha-trace-config\")\nexport class HaTraceConfig extends LitElement {\n  @property({ attribute: false }) public hass!: HomeAssistant;\n\n  @property({ attribute: false }) public trace!: TraceExtended;\n\n  protected render(): TemplateResult {\n    return html`\n      <ha-code-editor\n        .value=${dump(this.trace.config).trimRight()}\n        readOnly\n        dir=\"ltr\"\n      ></ha-code-editor>\n    `;\n  }\n\n  static get styles(): CSSResultGroup {\n    return [css``];\n  }\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"ha-trace-config\": HaTraceConfig;\n  }\n}\n","import { css, CSSResultGroup, html, LitElement, TemplateResult } from \"lit\";\nimport { customElement, property } from \"lit/decorators\";\nimport { LogbookEntry } from \"../../data/logbook\";\nimport { HomeAssistant } from \"../../types\";\nimport \"./hat-logbook-note\";\nimport \"../../panels/logbook/ha-logbook-renderer\";\nimport { TraceExtended } from \"../../data/trace\";\n\n@customElement(\"ha-trace-logbook\")\nexport class HaTraceLogbook extends LitElement {\n  @property({ attribute: false }) public hass!: HomeAssistant;\n\n  @property({ type: Boolean, reflect: true }) public narrow!: boolean;\n\n  @property({ attribute: false }) public trace!: TraceExtended;\n\n  @property({ attribute: false }) public logbookEntries!: LogbookEntry[];\n\n  protected render(): TemplateResult {\n    return this.logbookEntries.length\n      ? html`\n          <ha-logbook-renderer\n            relative-time\n            .hass=${this.hass}\n            .entries=${this.logbookEntries}\n            .narrow=${this.narrow}\n          ></ha-logbook-renderer>\n          <hat-logbook-note .domain=${this.trace.domain}></hat-logbook-note>\n        `\n      : html`<div class=\"padded-box\">\n          No Logbook entries found for this step.\n        </div>`;\n  }\n\n  static get styles(): CSSResultGroup {\n    return [\n      css`\n        .padded-box {\n          padding: 16px;\n        }\n      `,\n    ];\n  }\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"ha-trace-logbook\": HaTraceLogbook;\n  }\n}\n","import { dump } from \"js-yaml\";\nimport { css, CSSResultGroup, html, LitElement, TemplateResult } from \"lit\";\nimport { customElement, property, state } from \"lit/decorators\";\nimport { classMap } from \"lit/directives/class-map\";\nimport { formatDateTimeWithSeconds } from \"../../common/datetime/format_date_time\";\nimport \"../ha-code-editor\";\nimport \"../ha-icon-button\";\nimport \"./hat-logbook-note\";\nimport { LogbookEntry } from \"../../data/logbook\";\nimport {\n  ActionTraceStep,\n  ChooseActionTraceStep,\n  getDataFromPath,\n  TraceExtended,\n} from \"../../data/trace\";\nimport \"../../panels/logbook/ha-logbook-renderer\";\nimport { traceTabStyles } from \"./trace-tab-styles\";\nimport { HomeAssistant } from \"../../types\";\nimport type { NodeInfo } from \"./hat-script-graph\";\n\n@customElement(\"ha-trace-path-details\")\nexport class HaTracePathDetails extends LitElement {\n  @property({ attribute: false }) public hass!: HomeAssistant;\n\n  @property({ type: Boolean, reflect: true }) public narrow!: boolean;\n\n  @property({ attribute: false }) public trace!: TraceExtended;\n\n  @property({ attribute: false }) public logbookEntries!: LogbookEntry[];\n\n  @property({ attribute: false }) public selected!: NodeInfo;\n\n  @property() public renderedNodes: Record<string, any> = {};\n\n  @property() public trackedNodes!: Record<string, any>;\n\n  @state() private _view: \"config\" | \"changed_variables\" | \"logbook\" = \"config\";\n\n  protected render(): TemplateResult {\n    return html`\n      <div class=\"padded-box trace-info\">\n        ${this._renderSelectedTraceInfo()}\n      </div>\n\n      <div class=\"tabs top\">\n        ${[\n          [\"config\", \"Step Config\"],\n          [\"changed_variables\", \"Changed Variables\"],\n          [\"logbook\", \"Related logbook entries\"],\n        ].map(\n          ([view, label]) => html`\n            <button\n              .view=${view}\n              class=${classMap({ active: this._view === view })}\n              @click=${this._showTab}\n            >\n              ${label}\n            </button>\n          `\n        )}\n      </div>\n      ${this._view === \"config\"\n        ? this._renderSelectedConfig()\n        : this._view === \"changed_variables\"\n        ? this._renderChangedVars()\n        : this._renderLogbook()}\n    `;\n  }\n\n  private _renderSelectedTraceInfo() {\n    const paths = this.trace.trace;\n\n    if (!this.selected?.path) {\n      return \"Select a node on the left for more information.\";\n    }\n\n    // HACK: default choice node is not part of paths. We filter them out here by checking parent.\n    const pathParts = this.selected.path.split(\"/\");\n    if (pathParts[pathParts.length - 1] === \"default\") {\n      const parentTraceInfo = paths[\n        pathParts.slice(0, pathParts.length - 1).join(\"/\")\n      ] as ChooseActionTraceStep[];\n\n      if (parentTraceInfo && parentTraceInfo[0]?.result?.choice === \"default\") {\n        return \"The default action was executed because no options matched.\";\n      }\n    }\n\n    if (!(this.selected.path in paths)) {\n      return \"This node was not executed and so no further trace information is available.\";\n    }\n\n    const parts: TemplateResult[][] = [];\n\n    let active = false;\n\n    for (const curPath of Object.keys(this.trace.trace)) {\n      // Include all trace results until the next rendered node.\n      // Rendered nodes also include non-chosen choose paths.\n      if (active) {\n        if (curPath in this.renderedNodes) {\n          break;\n        }\n      } else if (curPath === this.selected.path) {\n        active = true;\n      } else {\n        continue;\n      }\n\n      const data: ActionTraceStep[] = paths[curPath];\n\n      parts.push(\n        data.map((trace, idx) => {\n          const { path, timestamp, result, error, changed_variables, ...rest } =\n            trace as any;\n\n          if (result?.enabled === false) {\n            return html`This node was disabled and skipped during execution so\n            no further trace information is available.`;\n          }\n\n          return html`\n            ${curPath === this.selected.path\n              ? \"\"\n              : html`<h2>${curPath.substr(this.selected.path.length + 1)}</h2>`}\n            ${data.length === 1 ? \"\" : html`<h3>Iteration ${idx + 1}</h3>`}\n            Executed:\n            ${formatDateTimeWithSeconds(\n              new Date(timestamp),\n              this.hass.locale\n            )}<br />\n            ${result\n              ? html`Result:\n                  <pre>${dump(result)}</pre>`\n              : error\n              ? html`<div class=\"error\">Error: ${error}</div>`\n              : \"\"}\n            ${Object.keys(rest).length === 0\n              ? \"\"\n              : html`<pre>${dump(rest)}</pre>`}\n          `;\n        })\n      );\n    }\n\n    return parts;\n  }\n\n  private _renderSelectedConfig() {\n    if (!this.selected?.path) {\n      return \"\";\n    }\n    const config = getDataFromPath(this.trace!.config, this.selected.path);\n    return config\n      ? html`<ha-code-editor\n          .value=${dump(config).trimRight()}\n          readOnly\n          dir=\"ltr\"\n        ></ha-code-editor>`\n      : \"Unable to find config\";\n  }\n\n  private _renderChangedVars() {\n    const paths = this.trace.trace;\n    const data: ActionTraceStep[] = paths[this.selected.path];\n\n    return html`\n      <div class=\"padded-box\">\n        ${data.map(\n          (trace, idx) => html`\n            ${idx > 0 ? html`<p>Iteration ${idx + 1}</p>` : \"\"}\n            ${Object.keys(trace.changed_variables || {}).length === 0\n              ? \"No variables changed\"\n              : html`<pre>${dump(trace.changed_variables).trimRight()}</pre>`}\n          `\n        )}\n      </div>\n    `;\n  }\n\n  private _renderLogbook() {\n    const paths = this.trace.trace;\n    const startTrace = paths[this.selected.path];\n    const trackedPaths = Object.keys(this.trackedNodes);\n    const index = trackedPaths.indexOf(this.selected.path);\n\n    if (index === -1) {\n      return html`<div class=\"padded-box\">Node not tracked.</div>`;\n    }\n\n    let entries: LogbookEntry[];\n\n    if (index === trackedPaths.length - 1) {\n      // it's the last entry. Find all logbook entries after start.\n      const startTime = new Date(startTrace[0].timestamp);\n      const idx = this.logbookEntries.findIndex(\n        (entry) => new Date(entry.when * 1000) >= startTime\n      );\n      if (idx === -1) {\n        entries = [];\n      } else {\n        entries = this.logbookEntries.slice(idx);\n      }\n    } else {\n      const nextTrace = paths[trackedPaths[index + 1]];\n\n      const startTime = new Date(startTrace[0].timestamp);\n      const endTime = new Date(nextTrace[0].timestamp);\n\n      entries = [];\n\n      for (const entry of this.logbookEntries || []) {\n        const entryDate = new Date(entry.when * 1000);\n        if (entryDate >= startTime) {\n          if (entryDate < endTime) {\n            entries.push(entry);\n          } else {\n            // All following entries are no longer valid.\n            break;\n          }\n        }\n      }\n    }\n\n    return entries.length\n      ? html`\n          <ha-logbook-renderer\n            relative-time\n            .hass=${this.hass}\n            .entries=${entries}\n            .narrow=${this.narrow}\n          ></ha-logbook-renderer>\n          <hat-logbook-note .domain=${this.trace.domain}></hat-logbook-note>\n        `\n      : html`<div class=\"padded-box\">\n          No Logbook entries found for this step.\n        </div>`;\n  }\n\n  private _showTab(ev) {\n    this._view = ev.target.view;\n  }\n\n  static get styles(): CSSResultGroup {\n    return [\n      traceTabStyles,\n      css`\n        .padded-box {\n          margin: 16px;\n        }\n\n        :host(:not([narrow])) .trace-info {\n          min-height: 250px;\n        }\n\n        pre {\n          margin: 0;\n        }\n\n        .error {\n          color: var(--error-color);\n        }\n      `,\n    ];\n  }\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"ha-trace-path-details\": HaTracePathDetails;\n  }\n}\n","import { css, CSSResultGroup, html, LitElement, TemplateResult } from \"lit\";\nimport { customElement, property } from \"lit/decorators\";\nimport \"./hat-logbook-note\";\nimport \"./hat-trace-timeline\";\nimport type { LogbookEntry } from \"../../data/logbook\";\nimport type { TraceExtended } from \"../../data/trace\";\nimport type { HomeAssistant } from \"../../types\";\nimport type { NodeInfo } from \"./hat-script-graph\";\n\n@customElement(\"ha-trace-timeline\")\nexport class HaTraceTimeline extends LitElement {\n  @property({ attribute: false }) public hass!: HomeAssistant;\n\n  @property({ attribute: false }) public trace!: TraceExtended;\n\n  @property({ attribute: false }) public logbookEntries!: LogbookEntry[];\n\n  @property({ attribute: false }) public selected!: NodeInfo;\n\n  protected render(): TemplateResult {\n    return html`\n      <hat-trace-timeline\n        .hass=${this.hass}\n        .trace=${this.trace}\n        .logbookEntries=${this.logbookEntries}\n        .selectedPath=${this.selected.path}\n        allowPick\n      >\n      </hat-trace-timeline>\n      <hat-logbook-note .domain=${this.trace.domain}></hat-logbook-note>\n    `;\n  }\n\n  static get styles(): CSSResultGroup {\n    return [\n      css`\n        :host {\n          display: block;\n          padding: 16px;\n        }\n      `,\n    ];\n  }\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"ha-trace-timeline\": HaTraceTimeline;\n  }\n}\n","import { css, html, LitElement } from \"lit\";\nimport { customElement, property } from \"lit/decorators\";\n\n@customElement(\"hat-logbook-note\")\nclass HatLogbookNote extends LitElement {\n  @property() public domain = \"automation\";\n\n  render() {\n    return html`\n      Not all shown logbook entries might be related to this ${this.domain}.\n    `;\n  }\n\n  static styles = css`\n    :host {\n      display: block;\n      text-align: center;\n      font-style: italic;\n      padding: 16px;\n      margin-top: 8px;\n    }\n  `;\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"hat-logbook-note\": HatLogbookNote;\n  }\n}\n","import { css, html, LitElement, svg } from \"lit\";\nimport { customElement, property, state } from \"lit/decorators\";\nimport { classMap } from \"lit/directives/class-map\";\nimport { BRANCH_HEIGHT, SPACING } from \"./hat-graph-const\";\n\ninterface BranchConfig {\n  x: number;\n  height: number;\n  start: boolean;\n  end: boolean;\n  track: boolean;\n}\n\n/**\n * @attribute active\n * @attribute track\n */\n@customElement(\"hat-graph-branch\")\nexport class HatGraphBranch extends LitElement {\n  @property({ reflect: true, type: Boolean }) disabled?: boolean;\n\n  @property({ type: Boolean }) selected?: boolean;\n\n  @property({ type: Boolean }) start = false;\n\n  @property({ type: Boolean }) short = false;\n\n  @state() _branches: BranchConfig[] = [];\n\n  private _totalWidth = 0;\n\n  private _maxHeight = 0;\n\n  private _updateBranches(ev: Event) {\n    let total_width = 0;\n    const heights: number[] = [];\n    const branches: BranchConfig[] = [];\n    (ev.target as HTMLSlotElement).assignedElements().forEach((c) => {\n      const width = c.clientWidth;\n      const height = c.clientHeight;\n      branches.push({\n        x: width / 2 + total_width,\n        height,\n        start: c.hasAttribute(\"graphStart\"),\n        end: c.hasAttribute(\"graphEnd\"),\n        track: c.hasAttribute(\"track\"),\n      });\n      total_width += width;\n      heights.push(height);\n    });\n    this._totalWidth = total_width;\n    this._maxHeight = Math.max(...heights);\n    this._branches = branches.sort((a, b) => {\n      if (a.track && !b.track) {\n        return 1;\n      }\n      if (a.track && b.track) {\n        return 0;\n      }\n      return -1;\n    });\n  }\n\n  render() {\n    return html`\n      <slot name=\"head\"></slot>\n      ${!this.start\n        ? svg`\n            <svg\n              id=\"top\"\n              width=\"${this._totalWidth}\"\n            >\n              ${this._branches.map((branch) =>\n                branch.start\n                  ? \"\"\n                  : svg`\n                  <path\n                    class=${classMap({\n                      track: branch.track,\n                    })}\n                    d=\"\n                      M ${this._totalWidth / 2} 0\n                      L ${branch.x} ${BRANCH_HEIGHT}\n                      \"/>\n                `\n              )}\n            </svg>\n          `\n        : \"\"}\n      <div id=\"branches\">\n        <svg id=\"lines\" width=${this._totalWidth} height=${this._maxHeight}>\n          ${this._branches.map((branch) => {\n            if (branch.end) return \"\";\n            return svg`\n                    <path\n                      class=${classMap({\n                        track: branch.track,\n                      })}\n                      d=\"\n                        M ${branch.x} ${branch.height}\n                        v ${this._maxHeight - branch.height}\n                        \"/>\n                  `;\n          })}\n        </svg>\n        <slot @slotchange=${this._updateBranches}></slot>\n      </div>\n\n      ${!this.short\n        ? svg`\n            <svg\n              id=\"bottom\"\n              width=\"${this._totalWidth}\"\n            >\n              ${this._branches.map((branch) => {\n                if (branch.end) return \"\";\n                return svg`\n                  <path\n                    class=${classMap({\n                      track: branch.track,\n                    })}\n                    d=\"\n                      M ${branch.x} 0\n                      V ${SPACING}\n                      L ${this._totalWidth / 2} ${BRANCH_HEIGHT + SPACING}\n                      \"/>\n                `;\n              })}\n            </svg>\n          `\n        : \"\"}\n    `;\n  }\n\n  static get styles() {\n    return css`\n      :host {\n        position: relative;\n        display: flex;\n        flex-direction: column;\n        align-items: center;\n      }\n      :host(:focus) {\n        outline: none;\n      }\n      #branches {\n        position: relative;\n        display: flex;\n        flex-direction: row;\n        align-items: start;\n      }\n      ::slotted(*) {\n        z-index: 1;\n      }\n      ::slotted([slot=\"head\"]) {\n        margin-bottom: calc(var(--hat-graph-branch-height) / -2);\n      }\n      #lines {\n        position: absolute;\n      }\n      #top {\n        height: var(--hat-graph-branch-height);\n      }\n      #bottom {\n        height: calc(var(--hat-graph-branch-height) + var(--hat-graph-spacing));\n      }\n      path {\n        stroke: var(--stroke-clr);\n        stroke-width: 2;\n        fill: none;\n      }\n      path.track {\n        stroke: var(--track-clr);\n      }\n      :host([disabled]) path {\n        stroke: var(--disabled-clr);\n      }\n    `;\n  }\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"hat-graph-branch\": HatGraphBranch;\n  }\n}\n","import {\n  css,\n  LitElement,\n  PropertyValues,\n  html,\n  TemplateResult,\n  svg,\n} from \"lit\";\nimport { customElement, property } from \"lit/decorators\";\nimport { NODE_SIZE, SPACING } from \"./hat-graph-const\";\n\n/**\n * @attribute active\n * @attribute track\n */\n@customElement(\"hat-graph-node\")\nexport class HatGraphNode extends LitElement {\n  @property() iconPath?: string;\n\n  @property({ reflect: true, type: Boolean }) disabled?: boolean;\n\n  @property({ reflect: true, type: Boolean }) notEnabled = false;\n\n  @property({ reflect: true, type: Boolean }) graphStart?: boolean;\n\n  @property({ type: Boolean, attribute: \"nofocus\" }) noFocus = false;\n\n  @property({ reflect: true, type: Number }) badge?: number;\n\n  protected updated(changedProps: PropertyValues) {\n    if (changedProps.has(\"noFocus\")) {\n      if (!this.hasAttribute(\"tabindex\") && !this.noFocus) {\n        this.setAttribute(\"tabindex\", \"0\");\n      } else if (changedProps.get(\"noFocus\") !== undefined && this.noFocus) {\n        this.removeAttribute(\"tabindex\");\n      }\n    }\n  }\n\n  protected render(): TemplateResult {\n    const height = NODE_SIZE + (this.graphStart ? 2 : SPACING + 1);\n    const width = SPACING + NODE_SIZE;\n    return html`\n      <svg\n        width=\"${width}px\"\n        height=\"${height}px\"\n        viewBox=\"-${Math.ceil(width / 2)} -${this.graphStart\n          ? Math.ceil(height / 2)\n          : Math.ceil((NODE_SIZE + SPACING * 2) / 2)} ${width} ${height}\"\n      >\n        ${this.graphStart\n          ? ``\n          : svg`\n          <path\n            class=\"connector\"\n            d=\"\n              M 0 ${-SPACING - NODE_SIZE / 2}\n              L 0 0\n            \"\n            line-caps=\"round\"\n          />\n          `}\n        <g class=\"node\">\n          <circle cx=\"0\" cy=\"0\" r=${NODE_SIZE / 2} />\n          }\n          ${this.badge\n            ? svg`\n        <g class=\"number\">\n          <circle\n            cx=\"8\"\n            cy=${-NODE_SIZE / 2}\n            r=\"8\"\n          ></circle>\n          <text\n            x=\"8\"\n            y=${-NODE_SIZE / 2}\n            text-anchor=\"middle\"\n            alignment-baseline=\"middle\"\n          >${this.badge > 9 ? \"9+\" : this.badge}</text>\n        </g>\n      `\n            : \"\"}\n          <g style=\"pointer-events: none\" transform=\"translate(${-12} ${-12})\">\n            ${this.iconPath ? svg`<path class=\"icon\" d=${this.iconPath}/>` : \"\"}\n          </g>\n        </g>\n      </svg>\n    `;\n  }\n\n  static get styles() {\n    return css`\n      :host {\n        display: flex;\n        flex-direction: column;\n        min-width: calc(var(--hat-graph-node-size) + var(--hat-graph-spacing));\n        height: calc(\n          var(--hat-graph-node-size) + var(--hat-graph-spacing) + 1px\n        );\n      }\n      :host([graphStart]) {\n        height: calc(var(--hat-graph-node-size) + 2px);\n      }\n      :host([track]) {\n        --stroke-clr: var(--track-clr);\n        --icon-clr: var(--default-icon-clr);\n      }\n      :host([active]) circle {\n        --stroke-clr: var(--active-clr);\n        --icon-clr: var(--default-icon-clr);\n      }\n      :host(:focus) {\n        outline: none;\n      }\n      :host(:hover) circle {\n        --stroke-clr: var(--hover-clr);\n        --icon-clr: var(--default-icon-clr);\n      }\n      :host([notEnabled]) circle {\n        --stroke-clr: var(--disabled-clr);\n      }\n      :host([notEnabled][active]) circle {\n        --stroke-clr: var(--disabled-active-clr);\n      }\n      :host([notEnabled]:hover) circle {\n        --stroke-clr: var(--disabled-hover-clr);\n      }\n      svg {\n        width: 100%;\n        height: 100%;\n      }\n      circle,\n      path.connector {\n        stroke: var(--stroke-clr);\n        stroke-width: 2;\n        fill: none;\n      }\n      circle {\n        fill: var(--background-clr);\n        stroke: var(--circle-clr, var(--stroke-clr));\n      }\n      .number circle {\n        fill: var(--track-clr);\n        stroke: none;\n        stroke-width: 0;\n      }\n      .number text {\n        font-size: smaller;\n      }\n      path.icon {\n        fill: var(--icon-clr);\n      }\n    `;\n  }\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"hat-graph-node\": HatGraphNode;\n  }\n}\n","import { css, LitElement, html } from \"lit\";\nimport { customElement, property } from \"lit/decorators\";\nimport { SPACING, NODE_SIZE } from \"./hat-graph-const\";\n\n/**\n * @attribute active\n * @attribute track\n */\n@customElement(\"hat-graph-spacer\")\nexport class HatGraphSpacer extends LitElement {\n  @property({ reflect: true, type: Boolean }) disabled?: boolean;\n\n  render() {\n    return html`\n      <svg viewBox=\"-${SPACING / 2} 0 10 ${SPACING + NODE_SIZE + 1}\">\n        <path\n          d=\"\n              M 0 ${SPACING + NODE_SIZE + 1}\n              V 0\n            \"\n          line-caps=\"round\"\n        />\n        }\n      </svg>\n    `;\n  }\n\n  static get styles() {\n    return css`\n      :host {\n        display: flex;\n        flex-direction: column;\n        align-items: center;\n      }\n      svg {\n        width: var(--hat-graph-spacing);\n        height: calc(\n          var(--hat-graph-spacing) + var(--hat-graph-node-size) + 1px\n        );\n      }\n      :host([track]) {\n        --stroke-clr: var(--track-clr);\n      }\n      :host-context([disabled]) {\n        --stroke-clr: var(--disabled-clr);\n      }\n      path {\n        stroke: var(--stroke-clr);\n        stroke-width: 2;\n        fill: none;\n      }\n    `;\n  }\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"hat-graph-spacer\": HatGraphSpacer;\n  }\n}\n","import {\n  mdiAbTesting,\n  mdiArrowDecision,\n  mdiArrowUp,\n  mdiAsterisk,\n  mdiCallMissed,\n  mdiCallReceived,\n  mdiCallSplit,\n  mdiCheckboxBlankOutline,\n  mdiCheckboxMarkedOutline,\n  mdiChevronDown,\n  mdiChevronUp,\n  mdiClose,\n  mdiCodeBraces,\n  mdiCodeBrackets,\n  mdiDevices,\n  mdiGestureDoubleTap,\n  mdiHandBackRight,\n  mdiPalette,\n  mdiRefresh,\n  mdiRoomService,\n  mdiShuffleDisabled,\n  mdiTimerOutline,\n} from \"@mdi/js\";\nimport { css, html, LitElement, PropertyValues } from \"lit\";\nimport { customElement, property } from \"lit/decorators\";\nimport { fireEvent } from \"../../common/dom/fire_event\";\nimport { ensureArray } from \"../../common/ensure-array\";\nimport { Condition, Trigger } from \"../../data/automation\";\nimport {\n  Action,\n  ChooseAction,\n  DelayAction,\n  DeviceAction,\n  EventAction,\n  IfAction,\n  ManualScriptConfig,\n  ParallelAction,\n  RepeatAction,\n  SceneAction,\n  ServiceAction,\n  WaitAction,\n  WaitForTriggerAction,\n} from \"../../data/script\";\nimport {\n  ChooseActionTraceStep,\n  ConditionTraceStep,\n  IfActionTraceStep,\n  TraceExtended,\n} from \"../../data/trace\";\nimport \"../ha-icon-button\";\nimport \"./hat-graph-branch\";\nimport { BRANCH_HEIGHT, NODE_SIZE, SPACING } from \"./hat-graph-const\";\nimport \"./hat-graph-node\";\nimport \"./hat-graph-spacer\";\n\nexport interface NodeInfo {\n  path: string;\n  config: any;\n}\n\ndeclare global {\n  interface HASSDomEvents {\n    \"graph-node-selected\": NodeInfo;\n  }\n}\n\n@customElement(\"hat-script-graph\")\nexport class HatScriptGraph extends LitElement {\n  @property({ attribute: false }) public trace!: TraceExtended;\n\n  @property({ attribute: false }) public selected?: string;\n\n  public renderedNodes: Record<string, NodeInfo> = {};\n\n  public trackedNodes: Record<string, NodeInfo> = {};\n\n  private selectNode(config, path) {\n    return () => {\n      fireEvent(this, \"graph-node-selected\", { config, path });\n    };\n  }\n\n  private render_trigger(config: Trigger, i: number) {\n    const path = `trigger/${i}`;\n    const track = this.trace && path in this.trace.trace;\n    this.renderedNodes[path] = { config, path };\n    if (track) {\n      this.trackedNodes[path] = this.renderedNodes[path];\n    }\n    return html`\n      <hat-graph-node\n        graphStart\n        ?track=${track}\n        @focus=${this.selectNode(config, path)}\n        ?active=${this.selected === path}\n        .iconPath=${mdiAsterisk}\n        .notEnabled=${config.enabled === false}\n        tabindex=${track ? \"0\" : \"-1\"}\n      ></hat-graph-node>\n    `;\n  }\n\n  private render_condition(config: Condition, i: number) {\n    const path = `condition/${i}`;\n    this.renderedNodes[path] = { config, path };\n    if (this.trace && path in this.trace.trace) {\n      this.trackedNodes[path] = this.renderedNodes[path];\n    }\n    return this.render_condition_node(config, path);\n  }\n\n  private typeRenderers = {\n    condition: this.render_condition_node,\n    and: this.render_condition_node,\n    or: this.render_condition_node,\n    not: this.render_condition_node,\n    delay: this.render_delay_node,\n    event: this.render_event_node,\n    scene: this.render_scene_node,\n    service: this.render_service_node,\n    wait_template: this.render_wait_node,\n    wait_for_trigger: this.render_wait_node,\n    repeat: this.render_repeat_node,\n    choose: this.render_choose_node,\n    device_id: this.render_device_node,\n    if: this.render_if_node,\n    stop: this.render_stop_node,\n    parallel: this.render_parallel_node,\n    other: this.render_other_node,\n  };\n\n  private render_action_node(\n    node: Action,\n    path: string,\n    graphStart = false,\n    disabled = false\n  ) {\n    const type =\n      Object.keys(this.typeRenderers).find((key) => key in node) || \"other\";\n    this.renderedNodes[path] = { config: node, path };\n    if (this.trace && path in this.trace.trace) {\n      this.trackedNodes[path] = this.renderedNodes[path];\n    }\n    return this.typeRenderers[type].bind(this)(\n      node,\n      path,\n      graphStart,\n      disabled\n    );\n  }\n\n  private render_choose_node(\n    config: ChooseAction,\n    path: string,\n    graphStart = false,\n    disabled = false\n  ) {\n    const trace = this.trace.trace[path] as ChooseActionTraceStep[] | undefined;\n    const trace_path = trace\n      ? trace.map((trc) =>\n          trc.result === undefined || trc.result.choice === \"default\"\n            ? \"default\"\n            : trc.result.choice\n        )\n      : [];\n    const track_default = trace_path.includes(\"default\");\n    return html`\n      <hat-graph-branch\n        tabindex=${trace === undefined ? \"-1\" : \"0\"}\n        @focus=${this.selectNode(config, path)}\n        ?track=${trace !== undefined}\n        ?active=${this.selected === path}\n        .notEnabled=${disabled || config.enabled === false}\n      >\n        <hat-graph-node\n          .graphStart=${graphStart}\n          .iconPath=${mdiArrowDecision}\n          ?track=${trace !== undefined}\n          ?active=${this.selected === path}\n          .notEnabled=${disabled || config.enabled === false}\n          slot=\"head\"\n          nofocus\n        ></hat-graph-node>\n\n        ${config.choose\n          ? ensureArray(config.choose)?.map((branch, i) => {\n              const branch_path = `${path}/choose/${i}`;\n              const track_this = trace_path.includes(i);\n              this.renderedNodes[branch_path] = { config, path: branch_path };\n              if (track_this) {\n                this.trackedNodes[branch_path] =\n                  this.renderedNodes[branch_path];\n              }\n              return html`\n                <div class=\"graph-container\" ?track=${track_this}>\n                  <hat-graph-node\n                    .iconPath=${!trace || track_this\n                      ? mdiCheckboxMarkedOutline\n                      : mdiCheckboxBlankOutline}\n                    @focus=${this.selectNode(config, branch_path)}\n                    ?track=${track_this}\n                    ?active=${this.selected === branch_path}\n                    .notEnabled=${disabled || config.enabled === false}\n                  ></hat-graph-node>\n                  ${branch.sequence !== null\n                    ? ensureArray(branch.sequence).map((action, j) =>\n                        this.render_action_node(\n                          action,\n                          `${branch_path}/sequence/${j}`,\n                          false,\n                          disabled || config.enabled === false\n                        )\n                      )\n                    : \"\"}\n                </div>\n              `;\n            })\n          : \"\"}\n        <div ?track=${track_default}>\n          <hat-graph-spacer ?track=${track_default}></hat-graph-spacer>\n          ${config.default !== null\n            ? ensureArray(config.default)?.map((action, i) =>\n                this.render_action_node(\n                  action,\n                  `${path}/default/${i}`,\n                  false,\n                  disabled || config.enabled === false\n                )\n              )\n            : \"\"}\n        </div>\n      </hat-graph-branch>\n    `;\n  }\n\n  private render_if_node(\n    config: IfAction,\n    path: string,\n    graphStart = false,\n    disabled = false\n  ) {\n    const trace = this.trace.trace[path] as IfActionTraceStep[] | undefined;\n    let trackThen = false;\n    let trackElse = false;\n    for (const trc of trace || []) {\n      if (!trackThen && trc.result?.choice === \"then\") {\n        trackThen = true;\n      }\n      if ((!trackElse && trc.result?.choice === \"else\") || !trc.result) {\n        trackElse = true;\n      }\n      if (trackElse && trackThen) {\n        break;\n      }\n    }\n    return html`\n      <hat-graph-branch\n        tabindex=${trace === undefined ? \"-1\" : \"0\"}\n        @focus=${this.selectNode(config, path)}\n        ?track=${trace !== undefined}\n        ?active=${this.selected === path}\n        .notEnabled=${disabled || config.enabled === false}\n      >\n        <hat-graph-node\n          .graphStart=${graphStart}\n          .iconPath=${mdiCallSplit}\n          ?track=${trace !== undefined}\n          ?active=${this.selected === path}\n          .notEnabled=${disabled || config.enabled === false}\n          slot=\"head\"\n          nofocus\n        ></hat-graph-node>\n        ${config.else\n          ? html`<div class=\"graph-container\" ?track=${trackElse}>\n              <hat-graph-node\n                .iconPath=${mdiCallMissed}\n                ?track=${trackElse}\n                ?active=${this.selected === path}\n                .notEnabled=${disabled || config.enabled === false}\n                nofocus\n              ></hat-graph-node\n              >${ensureArray(config.else).map((action, j) =>\n                this.render_action_node(\n                  action,\n                  `${path}/else/${j}`,\n                  false,\n                  disabled || config.enabled === false\n                )\n              )}\n            </div>`\n          : html`<hat-graph-spacer ?track=${trackElse}></hat-graph-spacer>`}\n        <div class=\"graph-container\" ?track=${trackThen}>\n          <hat-graph-node\n            .iconPath=${mdiCallReceived}\n            ?track=${trackThen}\n            ?active=${this.selected === path}\n            .notEnabled=${disabled || config.enabled === false}\n            nofocus\n          ></hat-graph-node>\n          ${ensureArray(config.then).map((action, j) =>\n            this.render_action_node(\n              action,\n              `${path}/then/${j}`,\n              false,\n              disabled || config.enabled === false\n            )\n          )}\n        </div>\n      </hat-graph-branch>\n    `;\n  }\n\n  private render_condition_node(\n    node: Condition,\n    path: string,\n    graphStart = false,\n    disabled = false\n  ) {\n    const trace = this.trace.trace[path] as ConditionTraceStep[] | undefined;\n    let track = false;\n    let trackPass = false;\n    let trackFailed = false;\n    if (trace) {\n      for (const trc of trace) {\n        if (trc.result) {\n          track = true;\n          if (trc.result.result) {\n            trackPass = true;\n          } else {\n            trackFailed = true;\n          }\n        }\n        if (trackPass && trackFailed) {\n          break;\n        }\n      }\n    }\n    return html`\n      <hat-graph-branch\n        @focus=${this.selectNode(node, path)}\n        ?track=${track}\n        ?active=${this.selected === path}\n        .notEnabled=${disabled || node.enabled === false}\n        tabindex=${trace === undefined ? \"-1\" : \"0\"}\n        short\n      >\n        <hat-graph-node\n          .graphStart=${graphStart}\n          slot=\"head\"\n          ?track=${track}\n          ?active=${this.selected === path}\n          .notEnabled=${disabled || node.enabled === false}\n          .iconPath=${mdiAbTesting}\n          nofocus\n        ></hat-graph-node>\n        <div\n          style=${`width: ${NODE_SIZE + SPACING}px;`}\n          graphStart\n          graphEnd\n        ></div>\n        <div ?track=${trackPass}></div>\n        <hat-graph-node\n          .iconPath=${mdiClose}\n          nofocus\n          ?track=${trackFailed}\n          ?active=${this.selected === path}\n          .notEnabled=${disabled || node.enabled === false}\n        ></hat-graph-node>\n      </hat-graph-branch>\n    `;\n  }\n\n  private render_delay_node(\n    node: DelayAction,\n    path: string,\n    graphStart = false,\n    disabled = false\n  ) {\n    return html`\n      <hat-graph-node\n        .graphStart=${graphStart}\n        .iconPath=${mdiTimerOutline}\n        @focus=${this.selectNode(node, path)}\n        ?track=${path in this.trace.trace}\n        ?active=${this.selected === path}\n        .notEnabled=${disabled || node.enabled === false}\n        tabindex=${this.trace && path in this.trace.trace ? \"0\" : \"-1\"}\n      ></hat-graph-node>\n    `;\n  }\n\n  private render_device_node(\n    node: DeviceAction,\n    path: string,\n    graphStart = false,\n    disabled = false\n  ) {\n    return html`\n      <hat-graph-node\n        .graphStart=${graphStart}\n        .iconPath=${mdiDevices}\n        @focus=${this.selectNode(node, path)}\n        ?track=${path in this.trace.trace}\n        ?active=${this.selected === path}\n        .notEnabled=${disabled || node.enabled === false}\n        tabindex=${this.trace && path in this.trace.trace ? \"0\" : \"-1\"}\n      ></hat-graph-node>\n    `;\n  }\n\n  private render_event_node(\n    node: EventAction,\n    path: string,\n    graphStart = false,\n    disabled = false\n  ) {\n    return html`\n      <hat-graph-node\n        .graphStart=${graphStart}\n        .iconPath=${mdiGestureDoubleTap}\n        @focus=${this.selectNode(node, path)}\n        ?track=${path in this.trace.trace}\n        ?active=${this.selected === path}\n        .notEnabled=${disabled || node.enabled === false}\n        tabindex=${this.trace && path in this.trace.trace ? \"0\" : \"-1\"}\n      ></hat-graph-node>\n    `;\n  }\n\n  private render_repeat_node(\n    node: RepeatAction,\n    path: string,\n    graphStart = false,\n    disabled = false\n  ) {\n    const trace: any = this.trace.trace[path];\n    const repeats = this.trace?.trace[`${path}/repeat/sequence/0`]?.length;\n    return html`\n      <hat-graph-branch\n        tabindex=${trace === undefined ? \"-1\" : \"0\"}\n        @focus=${this.selectNode(node, path)}\n        ?track=${path in this.trace.trace}\n        ?active=${this.selected === path}\n        .notEnabled=${disabled || node.enabled === false}\n      >\n        <hat-graph-node\n          .graphStart=${graphStart}\n          .iconPath=${mdiRefresh}\n          ?track=${path in this.trace.trace}\n          ?active=${this.selected === path}\n          .notEnabled=${disabled || node.enabled === false}\n          slot=\"head\"\n          nofocus\n        ></hat-graph-node>\n        <hat-graph-node\n          .iconPath=${mdiArrowUp}\n          ?track=${repeats > 1}\n          ?active=${this.selected === path}\n          .notEnabled=${disabled || node.enabled === false}\n          nofocus\n          .badge=${repeats > 1 ? repeats : undefined}\n        ></hat-graph-node>\n        <div ?track=${trace}>\n          ${ensureArray(node.repeat.sequence).map((action, i) =>\n            this.render_action_node(\n              action,\n              `${path}/repeat/sequence/${i}`,\n              false,\n              disabled || node.enabled === false\n            )\n          )}\n        </div>\n      </hat-graph-branch>\n    `;\n  }\n\n  private render_scene_node(\n    node: SceneAction,\n    path: string,\n    graphStart = false,\n    disabled = false\n  ) {\n    return html`\n      <hat-graph-node\n        .graphStart=${graphStart}\n        .iconPath=${mdiPalette}\n        @focus=${this.selectNode(node, path)}\n        ?track=${path in this.trace.trace}\n        ?active=${this.selected === path}\n        .notEnabled=${disabled || node.enabled === false}\n        tabindex=${this.trace && path in this.trace.trace ? \"0\" : \"-1\"}\n      ></hat-graph-node>\n    `;\n  }\n\n  private render_service_node(\n    node: ServiceAction,\n    path: string,\n    graphStart = false,\n    disabled = false\n  ) {\n    return html`\n      <hat-graph-node\n        .graphStart=${graphStart}\n        .iconPath=${mdiRoomService}\n        @focus=${this.selectNode(node, path)}\n        ?track=${path in this.trace.trace}\n        ?active=${this.selected === path}\n        .notEnabled=${disabled || node.enabled === false}\n        tabindex=${this.trace && path in this.trace.trace ? \"0\" : \"-1\"}\n      ></hat-graph-node>\n    `;\n  }\n\n  private render_wait_node(\n    node: WaitAction | WaitForTriggerAction,\n    path: string,\n    graphStart = false,\n    disabled = false\n  ) {\n    return html`\n      <hat-graph-node\n        .graphStart=${graphStart}\n        .iconPath=${mdiCodeBraces}\n        @focus=${this.selectNode(node, path)}\n        ?track=${path in this.trace.trace}\n        ?active=${this.selected === path}\n        .notEnabled=${disabled || node.enabled === false}\n        tabindex=${this.trace && path in this.trace.trace ? \"0\" : \"-1\"}\n      ></hat-graph-node>\n    `;\n  }\n\n  private render_parallel_node(\n    node: ParallelAction,\n    path: string,\n    graphStart = false,\n    disabled = false\n  ) {\n    const trace: any = this.trace.trace[path];\n    return html`\n      <hat-graph-branch\n        tabindex=${trace === undefined ? \"-1\" : \"0\"}\n        @focus=${this.selectNode(node, path)}\n        ?track=${path in this.trace.trace}\n        ?active=${this.selected === path}\n        .notEnabled=${disabled || node.enabled === false}\n      >\n        <hat-graph-node\n          .graphStart=${graphStart}\n          .iconPath=${mdiShuffleDisabled}\n          ?track=${path in this.trace.trace}\n          ?active=${this.selected === path}\n          .notEnabled=${disabled || node.enabled === false}\n          slot=\"head\"\n          nofocus\n        ></hat-graph-node>\n        ${ensureArray(node.parallel).map((action, i) =>\n          \"sequence\" in action\n            ? html`<div ?track=${path in this.trace.trace}>\n                ${ensureArray((action as ManualScriptConfig).sequence).map(\n                  (sAction, j) =>\n                    this.render_action_node(\n                      sAction,\n                      `${path}/parallel/${i}/sequence/${j}`,\n                      false,\n                      disabled || node.enabled === false\n                    )\n                )}\n              </div>`\n            : this.render_action_node(\n                action,\n                `${path}/parallel/${i}/sequence/0`,\n                false,\n                disabled || node.enabled === false\n              )\n        )}\n      </hat-graph-branch>\n    `;\n  }\n\n  private render_stop_node(\n    node: Action,\n    path: string,\n    graphStart = false,\n    disabled = false\n  ) {\n    return html`\n      <hat-graph-node\n        .graphStart=${graphStart}\n        .iconPath=${mdiHandBackRight}\n        @focus=${this.selectNode(node, path)}\n        ?track=${path in this.trace.trace}\n        ?active=${this.selected === path}\n        .notEnabled=${disabled || node.enabled === false}\n      ></hat-graph-node>\n    `;\n  }\n\n  private render_other_node(\n    node: Action,\n    path: string,\n    graphStart = false,\n    disabled = false\n  ) {\n    return html`\n      <hat-graph-node\n        .graphStart=${graphStart}\n        .iconPath=${mdiCodeBrackets}\n        @focus=${this.selectNode(node, path)}\n        ?track=${path in this.trace.trace}\n        ?active=${this.selected === path}\n        .notEnabled=${disabled || node.enabled === false}\n      ></hat-graph-node>\n    `;\n  }\n\n  protected render() {\n    const paths = Object.keys(this.trackedNodes);\n    const trigger_nodes =\n      \"trigger\" in this.trace.config\n        ? ensureArray(this.trace.config.trigger).map((trigger, i) =>\n            this.render_trigger(trigger, i)\n          )\n        : undefined;\n    try {\n      return html`\n        <div class=\"parent graph-container\">\n          ${trigger_nodes\n            ? html`<hat-graph-branch start .short=${trigger_nodes.length < 2}>\n                ${trigger_nodes}\n              </hat-graph-branch>`\n            : \"\"}\n          ${\"condition\" in this.trace.config\n            ? html`${ensureArray(this.trace.config.condition)?.map(\n                (condition, i) => this.render_condition(condition, i)\n              )}`\n            : \"\"}\n          ${\"action\" in this.trace.config\n            ? html`${ensureArray(this.trace.config.action).map((action, i) =>\n                this.render_action_node(action, `action/${i}`)\n              )}`\n            : \"\"}\n          ${\"sequence\" in this.trace.config\n            ? html`${ensureArray(this.trace.config.sequence).map((action, i) =>\n                this.render_action_node(action, `sequence/${i}`, i === 0)\n              )}`\n            : \"\"}\n        </div>\n        <div class=\"actions\">\n          <ha-icon-button\n            .disabled=${paths.length === 0 || paths[0] === this.selected}\n            @click=${this._previousTrackedNode}\n            .path=${mdiChevronUp}\n          ></ha-icon-button>\n          <ha-icon-button\n            .disabled=${paths.length === 0 ||\n            paths[paths.length - 1] === this.selected}\n            @click=${this._nextTrackedNode}\n            .path=${mdiChevronDown}\n          ></ha-icon-button>\n        </div>\n      `;\n    } catch (err: any) {\n      if (__DEV__) {\n        // eslint-disable-next-line no-console\n        console.log(\"Error creating script graph:\", err);\n      }\n      return html`\n        <div class=\"error\">\n          Error rendering graph. Please download trace and share with the\n          developers.\n        </div>\n      `;\n    }\n  }\n\n  public willUpdate(changedProps: PropertyValues<this>) {\n    super.willUpdate(changedProps);\n    if (changedProps.has(\"trace\")) {\n      this.renderedNodes = {};\n      this.trackedNodes = {};\n    }\n  }\n\n  protected updated(changedProps: PropertyValues<this>) {\n    super.updated(changedProps);\n\n    if (!changedProps.has(\"trace\")) {\n      return;\n    }\n\n    // If trace changed and we have no or an invalid selection, select first option.\n    if (!this.selected || !(this.selected in this.trackedNodes)) {\n      const firstNode = this.trackedNodes[Object.keys(this.trackedNodes)[0]];\n      if (firstNode) {\n        fireEvent(this, \"graph-node-selected\", firstNode);\n      }\n    }\n\n    if (this.trace) {\n      const sortKeys = Object.keys(this.trace.trace);\n      const keys = Object.keys(this.renderedNodes).sort(\n        (a, b) => sortKeys.indexOf(a) - sortKeys.indexOf(b)\n      );\n      const sortedTrackedNodes = {};\n      const sortedRenderedNodes = {};\n      for (const key of keys) {\n        sortedRenderedNodes[key] = this.renderedNodes[key];\n        if (key in this.trackedNodes) {\n          sortedTrackedNodes[key] = this.trackedNodes[key];\n        }\n      }\n      this.renderedNodes = sortedRenderedNodes;\n      this.trackedNodes = sortedTrackedNodes;\n    }\n  }\n\n  private _previousTrackedNode() {\n    const nodes = Object.keys(this.trackedNodes);\n    const prevIndex = nodes.indexOf(this.selected!) - 1;\n    if (prevIndex >= 0) {\n      fireEvent(\n        this,\n        \"graph-node-selected\",\n        this.trackedNodes[nodes[prevIndex]]\n      );\n    }\n  }\n\n  private _nextTrackedNode() {\n    const nodes = Object.keys(this.trackedNodes);\n    const nextIndex = nodes.indexOf(this.selected!) + 1;\n    if (nextIndex < nodes.length) {\n      fireEvent(\n        this,\n        \"graph-node-selected\",\n        this.trackedNodes[nodes[nextIndex]]\n      );\n    }\n  }\n\n  static get styles() {\n    return css`\n      :host {\n        display: flex;\n        --stroke-clr: var(--stroke-color, var(--secondary-text-color));\n        --active-clr: var(--active-color, var(--primary-color));\n        --track-clr: var(--track-color, var(--accent-color));\n        --hover-clr: var(--hover-color, var(--primary-color));\n        --disabled-clr: var(--disabled-color, var(--disabled-text-color));\n        --disabled-active-clr: rgba(var(--rgb-primary-color), 0.5);\n        --disabled-hover-clr: rgba(var(--rgb-primary-color), 0.7);\n        --default-trigger-color: 3, 169, 244;\n        --rgb-trigger-color: var(--trigger-color, var(--default-trigger-color));\n        --background-clr: var(--background-color, white);\n        --default-icon-clr: var(--icon-color, black);\n        --icon-clr: var(--stroke-clr);\n\n        --hat-graph-spacing: ${SPACING}px;\n        --hat-graph-node-size: ${NODE_SIZE}px;\n        --hat-graph-branch-height: ${BRANCH_HEIGHT}px;\n      }\n      .graph-container {\n        display: flex;\n        flex-direction: column;\n        align-items: center;\n      }\n      .actions {\n        display: flex;\n        flex-direction: column;\n      }\n      .parent {\n        margin-left: 8px;\n        margin-top: 16px;\n      }\n      .error {\n        padding: 16px;\n        max-width: 300px;\n      }\n    `;\n  }\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"hat-script-graph\": HatScriptGraph;\n  }\n}\n","export const SPACING = 10;\nexport const NODE_SIZE = 30;\nexport const BRANCH_HEIGHT = 20;\n","import {\n  mdiAlertCircle,\n  mdiCircle,\n  mdiCircleOutline,\n  mdiProgressClock,\n  mdiProgressWrench,\n  mdiRecordCircleOutline,\n} from \"@mdi/js\";\nimport {\n  css,\n  CSSResultGroup,\n  html,\n  LitElement,\n  PropertyValues,\n  TemplateResult,\n} from \"lit\";\nimport { customElement, property } from \"lit/decorators\";\nimport { ifDefined } from \"lit/directives/if-defined\";\nimport { formatDateTimeWithSeconds } from \"../../common/datetime/format_date_time\";\nimport { relativeTime } from \"../../common/datetime/relative_time\";\nimport { fireEvent } from \"../../common/dom/fire_event\";\nimport { toggleAttribute } from \"../../common/dom/toggle_attribute\";\nimport { LogbookEntry } from \"../../data/logbook\";\nimport {\n  ChooseAction,\n  ChooseActionChoice,\n  getActionType,\n  IfAction,\n  ParallelAction,\n  RepeatAction,\n} from \"../../data/script\";\nimport { describeAction } from \"../../data/script_i18n\";\nimport {\n  ActionTraceStep,\n  AutomationTraceExtended,\n  ChooseActionTraceStep,\n  getDataFromPath,\n  IfActionTraceStep,\n  isTriggerPath,\n  TriggerTraceStep,\n} from \"../../data/trace\";\nimport { HomeAssistant } from \"../../types\";\nimport \"./ha-timeline\";\nimport type { HaTimeline } from \"./ha-timeline\";\n\nconst LOGBOOK_ENTRIES_BEFORE_FOLD = 2;\n\n/* eslint max-classes-per-file: \"off\" */\n\n// Report time entry when more than this time has passed\nconst SIGNIFICANT_TIME_CHANGE = 1000; // 1 seconds\n\nconst isSignificantTimeChange = (a: Date, b: Date) =>\n  Math.abs(b.getTime() - a.getTime()) > SIGNIFICANT_TIME_CHANGE;\n\nclass RenderedTimeTracker {\n  private lastReportedTime: Date;\n\n  constructor(\n    private hass: HomeAssistant,\n    private entries: TemplateResult[],\n    trace: AutomationTraceExtended\n  ) {\n    this.lastReportedTime = new Date(trace.timestamp.start);\n  }\n\n  setLastReportedTime(date: Date) {\n    this.lastReportedTime = date;\n  }\n\n  renderTime(from: Date, to: Date): void {\n    this.entries.push(html`\n      <ha-timeline label>\n        ${relativeTime(from, this.hass.locale, to, false)} later\n      </ha-timeline>\n    `);\n    this.lastReportedTime = to;\n  }\n\n  maybeRenderTime(timestamp: Date): boolean {\n    if (!isSignificantTimeChange(timestamp, this.lastReportedTime)) {\n      this.lastReportedTime = timestamp;\n      return false;\n    }\n\n    this.renderTime(this.lastReportedTime, timestamp);\n    return true;\n  }\n}\n\nclass LogbookRenderer {\n  private curIndex: number;\n\n  private pendingItems: Array<[Date, LogbookEntry]> = [];\n\n  constructor(\n    private entries: TemplateResult[],\n    private timeTracker: RenderedTimeTracker,\n    private logbookEntries: LogbookEntry[]\n  ) {\n    // Skip the \"automation got triggered item\"\n    this.curIndex =\n      logbookEntries.length > 0 && logbookEntries[0].domain === \"automation\"\n        ? 1\n        : 0;\n  }\n\n  get curItem() {\n    return this.logbookEntries[this.curIndex];\n  }\n\n  get hasNext() {\n    return this.curIndex < this.logbookEntries.length;\n  }\n\n  maybeRenderItem() {\n    const logbookEntry = this.curItem;\n    this.curIndex++;\n    const entryDate = new Date(logbookEntry.when * 1000);\n\n    if (this.pendingItems.length === 0) {\n      this.pendingItems.push([entryDate, logbookEntry]);\n      return;\n    }\n\n    const previousEntryDate =\n      this.pendingItems[this.pendingItems.length - 1][0];\n\n    // If logbook entry is too long after the last one,\n    // add a time passed label\n    if (isSignificantTimeChange(previousEntryDate, entryDate)) {\n      this._renderLogbookEntries();\n      this.timeTracker.renderTime(previousEntryDate, entryDate);\n    }\n\n    this.pendingItems.push([entryDate, logbookEntry]);\n  }\n\n  flush() {\n    if (this.pendingItems.length > 0) {\n      this._renderLogbookEntries();\n    }\n  }\n\n  private _renderLogbookEntries() {\n    this.timeTracker.maybeRenderTime(this.pendingItems[0][0]);\n\n    const parts: TemplateResult[] = [];\n\n    let i;\n\n    for (\n      i = 0;\n      i < Math.min(this.pendingItems.length, LOGBOOK_ENTRIES_BEFORE_FOLD);\n      i++\n    ) {\n      parts.push(this._renderLogbookEntryHelper(this.pendingItems[i][1]));\n    }\n\n    let moreItems: TemplateResult[] | undefined;\n\n    // If we didn't render all items, push rest into `moreItems`\n    if (i < this.pendingItems.length) {\n      moreItems = [];\n      for (; i < this.pendingItems.length; i++) {\n        moreItems.push(this._renderLogbookEntryHelper(this.pendingItems[i][1]));\n      }\n    }\n\n    this.entries.push(html`\n      <ha-timeline .icon=${mdiCircleOutline} .moreItems=${moreItems}>\n        ${parts}\n      </ha-timeline>\n    `);\n\n    // Clear rendered items.\n    this.timeTracker.setLastReportedTime(\n      this.pendingItems[this.pendingItems.length - 1][0]\n    );\n    this.pendingItems = [];\n  }\n\n  private _renderLogbookEntryHelper(entry: LogbookEntry) {\n    return html`${entry.name} (${entry.entity_id})\n      ${entry.message || `turned ${entry.state}`}<br />`;\n  }\n}\n\nclass ActionRenderer {\n  private curIndex = 0;\n\n  private keys: string[];\n\n  constructor(\n    private hass: HomeAssistant,\n    private entries: TemplateResult[],\n    private trace: AutomationTraceExtended,\n    private logbookRenderer: LogbookRenderer,\n    private timeTracker: RenderedTimeTracker\n  ) {\n    this.keys = Object.keys(trace.trace);\n  }\n\n  get curItem() {\n    return this._getItem(this.curIndex);\n  }\n\n  get hasNext() {\n    return this.curIndex < this.keys.length;\n  }\n\n  renderItem() {\n    this.curIndex = this._renderItem(this.curIndex);\n  }\n\n  private _getItem(index: number) {\n    return this.trace.trace[this.keys[index]];\n  }\n\n  private _renderItem(\n    index: number,\n    actionType?: ReturnType<typeof getActionType>,\n    renderAllIterations?: boolean\n  ): number {\n    const value = this._getItem(index);\n\n    if (renderAllIterations) {\n      let i;\n      value.forEach((item) => {\n        i = this._renderIteration(index, item, actionType);\n      });\n      return i;\n    }\n    return this._renderIteration(index, value[0], actionType);\n  }\n\n  private _renderIteration(\n    index: number,\n    value: ActionTraceStep,\n    actionType?: ReturnType<typeof getActionType>\n  ) {\n    if (isTriggerPath(value.path)) {\n      return this._handleTrigger(index, value as TriggerTraceStep);\n    }\n\n    const timestamp = new Date(value.timestamp);\n\n    // Render all logbook items that are in front of this item.\n    while (\n      this.logbookRenderer.hasNext &&\n      new Date(this.logbookRenderer.curItem.when * 1000) < timestamp\n    ) {\n      this.logbookRenderer.maybeRenderItem();\n    }\n\n    this.logbookRenderer.flush();\n    this.timeTracker.maybeRenderTime(timestamp);\n\n    const path = value.path;\n    let data;\n    try {\n      data = getDataFromPath(this.trace.config, path);\n    } catch (err: any) {\n      this._renderEntry(\n        path,\n        `Unable to extract path ${path}. Download trace and report as bug`\n      );\n      return index + 1;\n    }\n\n    const parts = path.split(\"/\");\n    const isTopLevel = parts.length === 2;\n\n    if (!isTopLevel && !actionType) {\n      this._renderEntry(path, path.replace(/\\//g, \" \"));\n      return index + 1;\n    }\n\n    if (!actionType) {\n      actionType = getActionType(data);\n    }\n\n    if (actionType === \"choose\") {\n      return this._handleChoose(index);\n    }\n\n    if (actionType === \"repeat\") {\n      return this._handleRepeat(index);\n    }\n\n    if (actionType === \"if\") {\n      return this._handleIf(index);\n    }\n\n    if (actionType === \"parallel\") {\n      return this._handleParallel(index);\n    }\n\n    this._renderEntry(\n      path,\n      describeAction(this.hass, data, actionType),\n      undefined,\n      data.enabled === false\n    );\n\n    let i = index + 1;\n\n    for (; i < this.keys.length; i++) {\n      if (this.keys[i].split(\"/\").length === parts.length) {\n        break;\n      }\n    }\n\n    return i;\n  }\n\n  private _handleTrigger(index: number, triggerStep: TriggerTraceStep): number {\n    this._renderEntry(\n      triggerStep.path,\n      `${\n        triggerStep.changed_variables.trigger.alias\n          ? `${triggerStep.changed_variables.trigger.alias} triggered`\n          : \"Triggered\"\n      } ${\n        triggerStep.path === \"trigger\"\n          ? \"manually\"\n          : `by the ${this.trace.trigger}`\n      } at\n    ${formatDateTimeWithSeconds(\n      new Date(triggerStep.timestamp),\n      this.hass.locale\n    )}`,\n      mdiCircle\n    );\n    return index + 1;\n  }\n\n  private _handleChoose(index: number): number {\n    // startLevel: choose root config\n\n    // +1: 'default\n    // +2: executed sequence\n\n    // +1: 'choose'\n    // +2: current choice\n\n    // +3: 'conditions'\n    // +4: evaluated condition\n\n    // +3: 'sequence'\n    // +4: executed sequence\n\n    const choosePath = this.keys[index];\n    const startLevel = choosePath.split(\"/\").length;\n\n    const chooseTrace = this._getItem(index)[0] as ChooseActionTraceStep;\n    const defaultExecuted = chooseTrace.result?.choice === \"default\";\n    const chooseConfig = this._getDataFromPath(\n      this.keys[index]\n    ) as ChooseAction;\n    const disabled = chooseConfig.enabled === false;\n    const name = chooseConfig.alias || \"Choose\";\n\n    if (defaultExecuted) {\n      this._renderEntry(\n        choosePath,\n        `${name}: Default action executed`,\n        undefined,\n        disabled\n      );\n    } else if (chooseTrace.result) {\n      const choiceNumeric =\n        chooseTrace.result.choice !== \"default\"\n          ? chooseTrace.result.choice + 1\n          : undefined;\n      const choiceConfig = this._getDataFromPath(\n        `${this.keys[index]}/choose/${chooseTrace.result.choice}`\n      ) as ChooseActionChoice | undefined;\n      const choiceName = choiceConfig\n        ? `${choiceConfig.alias || `Option ${choiceNumeric}`} executed`\n        : `Error: ${chooseTrace.error}`;\n      this._renderEntry(\n        choosePath,\n        `${name}: ${choiceName}`,\n        undefined,\n        disabled\n      );\n    } else {\n      this._renderEntry(\n        choosePath,\n        `${name}: No action taken`,\n        undefined,\n        disabled\n      );\n    }\n\n    let i;\n\n    // Skip over conditions\n    for (i = index + 1; i < this.keys.length; i++) {\n      const parts = this.keys[i].split(\"/\");\n\n      // We're done if no more sequence in current level\n      if (parts.length <= startLevel) {\n        return i;\n      }\n\n      // We're going to skip all conditions\n      if (\n        (defaultExecuted && parts[startLevel + 1] === \"default\") ||\n        (!defaultExecuted && parts[startLevel + 3] === \"sequence\")\n      ) {\n        break;\n      }\n    }\n\n    // Render choice\n    while (i < this.keys.length) {\n      const path = this.keys[i];\n      const parts = path.split(\"/\");\n\n      // We're done if no more sequence in current level\n      if (parts.length <= startLevel) {\n        return i;\n      }\n\n      // We know it's an action sequence, so force the type like that\n      // for rendering.\n      i = this._renderItem(i, getActionType(this._getDataFromPath(path)));\n    }\n\n    return i;\n  }\n\n  private _handleRepeat(index: number): number {\n    const repeatPath = this.keys[index];\n    const startLevel = repeatPath.split(\"/\").length;\n\n    const repeatConfig = this._getDataFromPath(\n      this.keys[index]\n    ) as RepeatAction;\n    const disabled = repeatConfig.enabled === false;\n\n    const name = repeatConfig.alias || describeAction(this.hass, repeatConfig);\n\n    this._renderEntry(repeatPath, name, undefined, disabled);\n\n    let i;\n\n    for (i = index + 1; i < this.keys.length; i++) {\n      const path = this.keys[i];\n      const parts = path.split(\"/\");\n\n      // We're done if no more sequence in current level\n      if (parts.length <= startLevel) {\n        return i;\n      }\n\n      i = this._renderItem(i, getActionType(this._getDataFromPath(path)), true);\n    }\n\n    return i;\n  }\n\n  private _handleIf(index: number): number {\n    const ifPath = this.keys[index];\n    const startLevel = ifPath.split(\"/\").length;\n\n    const ifTrace = this._getItem(index)[0] as IfActionTraceStep;\n    const ifConfig = this._getDataFromPath(this.keys[index]) as IfAction;\n    const disabled = ifConfig.enabled === false;\n    const name = ifConfig.alias || \"If\";\n\n    if (ifTrace.result?.choice) {\n      const choiceConfig = this._getDataFromPath(\n        `${this.keys[index]}/${ifTrace.result.choice}/`\n      ) as any;\n      const choiceName = choiceConfig\n        ? `${choiceConfig.alias || `${ifTrace.result.choice} action executed`}`\n        : `Error: ${ifTrace.error}`;\n      this._renderEntry(ifPath, `${name}: ${choiceName}`, undefined, disabled);\n    } else {\n      this._renderEntry(\n        ifPath,\n        `${name}: No action taken`,\n        undefined,\n        disabled\n      );\n    }\n\n    let i;\n\n    // Skip over conditions\n    for (i = index + 1; i < this.keys.length; i++) {\n      const path = this.keys[i];\n      const parts = this.keys[i].split(\"/\");\n\n      // We're done if no more sequence in current level\n      if (parts.length <= startLevel) {\n        return i;\n      }\n\n      // We're going to skip all conditions\n      if (\n        parts[startLevel + 1] === \"condition\" ||\n        parts.length < startLevel + 2\n      ) {\n        continue;\n      }\n\n      i = this._renderItem(i, getActionType(this._getDataFromPath(path)));\n    }\n\n    return i;\n  }\n\n  private _handleParallel(index: number): number {\n    const parallelPath = this.keys[index];\n    const startLevel = parallelPath.split(\"/\").length;\n\n    const parallelConfig = this._getDataFromPath(\n      this.keys[index]\n    ) as ParallelAction;\n\n    const disabled = parallelConfig.enabled === false;\n\n    const name = parallelConfig.alias || \"Execute in parallel\";\n\n    this._renderEntry(parallelPath, name, undefined, disabled);\n\n    let i;\n\n    for (i = index + 1; i < this.keys.length; i++) {\n      const path = this.keys[i];\n      const parts = path.split(\"/\");\n\n      // We're done if no more sequence in current level\n      if (parts.length <= startLevel) {\n        return i;\n      }\n\n      i = this._renderItem(i, getActionType(this._getDataFromPath(path)));\n    }\n\n    return i;\n  }\n\n  private _renderEntry(\n    path: string,\n    description: string,\n    icon = mdiRecordCircleOutline,\n    disabled = false\n  ) {\n    this.entries.push(html`\n      <ha-timeline .icon=${icon} data-path=${path} .notEnabled=${disabled}>\n        ${description}${disabled\n          ? html`<span class=\"disabled\"> (disabled)</span>`\n          : \"\"}\n      </ha-timeline>\n    `);\n  }\n\n  private _getDataFromPath(path: string) {\n    return getDataFromPath(this.trace.config, path);\n  }\n}\n\n@customElement(\"hat-trace-timeline\")\nexport class HaAutomationTracer extends LitElement {\n  @property({ attribute: false }) public hass!: HomeAssistant;\n\n  @property({ attribute: false }) public trace?: AutomationTraceExtended;\n\n  @property({ attribute: false }) public logbookEntries?: LogbookEntry[];\n\n  @property({ attribute: false }) public selectedPath?: string;\n\n  @property({ type: Boolean }) public allowPick = false;\n\n  protected render(): TemplateResult {\n    if (!this.trace) {\n      return html``;\n    }\n\n    const entries: TemplateResult[] = [];\n\n    const timeTracker = new RenderedTimeTracker(this.hass, entries, this.trace);\n    const logbookRenderer = new LogbookRenderer(\n      entries,\n      timeTracker,\n      this.logbookEntries || []\n    );\n    const actionRenderer = new ActionRenderer(\n      this.hass,\n      entries,\n      this.trace,\n      logbookRenderer,\n      timeTracker\n    );\n\n    while (actionRenderer.hasNext) {\n      actionRenderer.renderItem();\n    }\n\n    while (logbookRenderer.hasNext) {\n      logbookRenderer.maybeRenderItem();\n    }\n\n    logbookRenderer.flush();\n\n    // Render footer\n    const renderFinishedAt = () =>\n      formatDateTimeWithSeconds(\n        new Date(this.trace!.timestamp.finish!),\n        this.hass.locale\n      );\n    const renderRuntime = () => `(runtime:\n      ${(\n        (new Date(this.trace!.timestamp.finish!).getTime() -\n          new Date(this.trace!.timestamp.start).getTime()) /\n        1000\n      ).toFixed(2)}\n      seconds)`;\n\n    let entry: {\n      description: TemplateResult | string;\n      icon: string;\n      className?: string;\n    };\n\n    if (this.trace.state === \"running\") {\n      entry = {\n        description: \"Still running\",\n        icon: mdiProgressClock,\n      };\n    } else if (this.trace.state === \"debugged\") {\n      entry = {\n        description: \"Debugged\",\n        icon: mdiProgressWrench,\n      };\n    } else if (this.trace.script_execution === \"finished\") {\n      entry = {\n        description: `Finished at ${renderFinishedAt()} ${renderRuntime()}`,\n        icon: mdiCircle,\n      };\n    } else if (this.trace.script_execution === \"aborted\") {\n      entry = {\n        description: `Aborted at ${renderFinishedAt()} ${renderRuntime()}`,\n        icon: mdiAlertCircle,\n      };\n    } else if (this.trace.script_execution === \"cancelled\") {\n      entry = {\n        description: `Cancelled at ${renderFinishedAt()} ${renderRuntime()}`,\n        icon: mdiAlertCircle,\n      };\n    } else {\n      let reason: string;\n      let isError = false;\n      let extra: TemplateResult | undefined;\n\n      switch (this.trace.script_execution) {\n        case \"failed_conditions\":\n          reason = \"a condition failed\";\n          break;\n        case \"failed_single\":\n          reason = \"only a single execution is allowed\";\n          break;\n        case \"failed_max_runs\":\n          reason = \"maximum number of parallel runs reached\";\n          break;\n        case \"error\":\n          reason = \"an error was encountered\";\n          isError = true;\n          extra = html`<br /><br />${this.trace.error!}`;\n          break;\n        default:\n          reason = `of unknown reason \"${this.trace.script_execution}\"`;\n          isError = true;\n      }\n\n      entry = {\n        description: html`Stopped because ${reason} at ${renderFinishedAt()}\n        ${renderRuntime()}${extra || \"\"}`,\n        icon: mdiAlertCircle,\n        className: isError ? \"error\" : undefined,\n      };\n    }\n\n    entries.push(html`\n      <ha-timeline\n        lastItem\n        .icon=${entry.icon}\n        class=${ifDefined(entry.className)}\n      >\n        ${entry.description}\n      </ha-timeline>\n    `);\n\n    return html`${entries}`;\n  }\n\n  protected updated(props: PropertyValues) {\n    super.updated(props);\n\n    // Pick first path when we load a new trace.\n    if (\n      this.allowPick &&\n      props.has(\"trace\") &&\n      this.trace &&\n      this.selectedPath &&\n      !(this.selectedPath in this.trace.trace)\n    ) {\n      const element = this.shadowRoot!.querySelector<HaTimeline>(\n        \"ha-timeline[data-path]\"\n      );\n      if (element) {\n        fireEvent(this, \"value-changed\", { value: element.dataset.path });\n        this.selectedPath = element.dataset.path;\n      }\n    }\n\n    if (props.has(\"trace\") || props.has(\"selectedPath\")) {\n      this.shadowRoot!.querySelectorAll<HaTimeline>(\n        \"ha-timeline[data-path]\"\n      ).forEach((el) => {\n        toggleAttribute(el, \"selected\", this.selectedPath === el.dataset.path);\n        if (!this.allowPick || el.tabIndex === 0) {\n          return;\n        }\n        el.tabIndex = 0;\n        const selectEl = () => {\n          this.selectedPath = el.dataset.path;\n          fireEvent(this, \"value-changed\", { value: el.dataset.path });\n        };\n        el.addEventListener(\"click\", selectEl);\n        el.addEventListener(\"keydown\", (ev: KeyboardEvent) => {\n          if (ev.key === \"Enter\" || ev.key === \" \") {\n            selectEl();\n          }\n        });\n        el.addEventListener(\"mouseover\", () => {\n          el.raised = true;\n        });\n        el.addEventListener(\"mouseout\", () => {\n          el.raised = false;\n        });\n      });\n    }\n  }\n\n  static get styles(): CSSResultGroup {\n    return [\n      css`\n        ha-timeline[lastItem].condition {\n          --timeline-ball-color: var(--error-color);\n        }\n        ha-timeline[data-path] {\n          cursor: pointer;\n        }\n        ha-timeline[selected] {\n          --timeline-ball-color: var(--primary-color);\n        }\n        ha-timeline:focus {\n          outline: none;\n          --timeline-ball-color: var(--accent-color);\n        }\n        .error {\n          --timeline-ball-color: var(--error-color);\n          color: var(--error-color);\n        }\n      `,\n    ];\n  }\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"hat-trace-timeline\": HaAutomationTracer;\n  }\n}\n"],"names":[],"sourceRoot":""}